---
import '../styles/global.pcss';
/// <reference types="astro/client" />

// --- Props and Date Logic (変更なし) ---
const rawProps = (Astro.props as any).frontmatter ?? Astro.props;
const { title, description, author, tags, date, pubDate } = rawProps as {
  title: string;
  description?: string;
  author?: string;
  tags?: string[];
  date?: string | Date;
  pubDate?: string;
};

let sourceDate: string | Date | undefined = date ?? pubDate;
let parsedDate: Date | null = null;
let isoDate = '';
// (日付処理の堅牢化は前回のコードを維持)
if (typeof sourceDate === 'string') {
  try {
    parsedDate = new Date(sourceDate);
    if (isNaN(parsedDate.valueOf())) {
      parsedDate = null; console.warn(`Invalid date string: ${sourceDate}`);
    } else { isoDate = parsedDate.toISOString(); }
  } catch (e) { console.error(`Error parsing date: ${sourceDate}`, e); parsedDate = null; }
} else if (sourceDate instanceof Date) {
  if (!isNaN(sourceDate.valueOf())) {
    parsedDate = sourceDate; isoDate = parsedDate.toISOString();
  } else { console.warn(`Invalid Date object.`); parsedDate = null; }
}
const validDate = parsedDate instanceof Date;
const displayDate = validDate ? parsedDate!.toLocaleDateString('ja-JP', { year: 'numeric', month: '2-digit', day: '2-digit' }) : '';
---

<html lang="ja" class="bg-black">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>{title}</title>
    <base href="/" />
    {description && <meta name="description" content={description} />}

    {/* --- Performance: Preconnect to CDNs --- */}
    <link rel="preconnect" href="https://cdn.jsdelivr.net" />

    {/* --- KaTeX CSS (遅延読み込み - 必須) --- */}
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'" />
    <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css" /></noscript>

    {/* --- Mermaid CSS (遅延読み込み) --- */}
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'" />
    <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.css" /></noscript>

    {/* --- KaTeX Font Display (変更なし) --- */}
    <style is:inline>
      /* @font-face ルール (font-display: swap) */
      @font-face {font-family: 'KaTeX_AMS'; src: url(https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/fonts/KaTeX_AMS-Regular.woff2) format('woff2'), url(https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/fonts/KaTeX_AMS-Regular.woff) format('woff'); font-weight: normal; font-style: normal; font-display: swap;}
      /* 他のKaTeXフォントも同様に記述... */
      @font-face {font-family: 'KaTeX_Main'; src: url(https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/fonts/KaTeX_Main-Regular.woff2) format('woff2'), url(https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/fonts/KaTeX_Main-Regular.woff) format('woff'); font-weight: normal; font-style: normal; font-display: swap;}
      /* ... (省略: 前回のコードと同じ全フォント定義) ... */
      @font-face {font-family: 'KaTeX_Typewriter'; src: url(https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/fonts/KaTeX_Typewriter-Regular.woff2) format('woff2'), url(https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/fonts/KaTeX_Typewriter-Regular.woff) format('woff'); font-weight: normal; font-style: normal; font-display: swap;}
    </style>

    {/* --- Other Styles (Mermaid + KaTeXプレースホルダー) --- */}
    <style>
      /* Mermaid プレースホルダーとコンテナ (変更なし) */
      pre.mermaid[data-mermaid-processed="pending"] { min-height: 100px; display: flex; align-items: center; justify-content: center; background-color: rgba(255, 255, 255, 0.03); border-radius: 8px; border: 1px dashed rgba(255, 255, 255, 0.2); color: rgba(255, 255, 255, 0.5); font-style: italic; text-align: center; padding: 1em; margin: 1.5em 0; overflow: hidden; }
      pre.mermaid[data-mermaid-processed="pending"]::before { content: 'Loading diagram...'; }
      .mermaid-container { display: flex; justify-content: center; overflow-x: auto; margin: 1.5em 0; max-width: 100%; }
      .mermaid-container svg { max-width: none; display: block; }
      .mermaid-error-container { background-color: #400; color: #fcc; border: 1px solid #c00; padding: 1em; margin: 1.5em 0; border-radius: 8px; white-space: pre-wrap; word-break: break-all; font-family: monospace; overflow-x: auto; }

      /* KaTeX プレースホルダー スタイル (新規追加) */
      .katex-pending {
        display: inline-block; /* インライン要素用 */
        min-width: 2em; /* 最低幅 */
        min-height: 1.2em; /* 最低高 (line-heightに合わせる) */
        background-color: rgba(255, 255, 255, 0.05);
        border-radius: 3px;
        vertical-align: middle; /* 周囲のテキストと揃える */
        margin: 0 0.1em; /* 左右に少しマージン */
      }
      .math-block.katex-pending { /* ブロック要素用 */
        display: block;
        min-height: 3em; /* ブロックは高めに */
        width: 80%; /* 幅を適当に */
        margin: 1em auto; /* 中央揃え */
        padding: 0.5em;
        box-sizing: border-box;
      }
      /* KaTeX レンダリング後のスタイル調整が必要な場合ここに記述 */
      .katex-display { /* ブロック数式 */
         overflow-x: auto;
         overflow-y: hidden;
         padding: 0.5em 0;
      }

      /* その他 (変更なし) */
      .prose pre code { position: relative; }
    </style>
</head>

<body class="bg-black text-white">
    {/* --- Header (変更なし) --- */}
    <header class="fixed inset-x-0 top-0 z-50 bg-black border-b border-gray-800">
      <nav class="container mx-auto flex items-center justify-between py-4 px-6">
        <a href="/" class="text-white font-semibold text-lg">Mekann</a>
        <ul class="flex gap-6 text-sm">
          <li><a href="/" class="text-gray-400 hover:text-white no-underline">Home</a></li>
          <li><a href="/blog" class="text-gray-400 hover:text-white no-underline">Blog</a></li>
        </ul>
      </nav>
    </header>

    {/* --- Main Content (変更なし) --- */}
    <main class="pt-20 container mx-auto px-6 py-8">
      <article class="prose prose-invert mx-auto max-w-3xl py-8 relative ...">
        <a href="/blog/" class="inline-flex items-center text-gray-500 hover:text-white mb-4 no-underline"> ← Back to Blog </a>
        {validDate && ( <div class="flex ..."><time datetime={isoDate}>{displayDate}</time>{author && <span class="mt-1 ...">By {author}</span>}</div> )}
        <h1 class="text-4xl font-bold text-white mb-6">{title}</h1>
        {description && <p class="text-gray-300 mb-8">{description}</p>}

        {/* Markdown/MDXコンテンツ: KaTeXはクライアントでレンダリングされる */}
        <slot />

        {tags && tags.length > 0 && ( <div class="mt-12 ...">{tags.map((tag) => ( <a href={`/tags/${tag}`} class="...">#{tag}</a> ))}</div> )}
      </article>
    </main>

    {/* --- Footer (変更なし) --- */}
    <footer class="bg-black text-gray-400 border-t border-gray-800 py-6">
      <div class="container mx-auto text-center text-sm"> © {new Date().getFullYear()} Mekann </div>
    </footer>

    {/* --- クライアントサイドスクリプト (大幅変更) --- */}
    <script type="module">
      let mermaidInstance = null;
      let mermaidIntersectionObserver = null;
      const mermaidElementsToProcess = new Set();

      let katexInstance = null; // KaTeX インスタンス用
      let katexIntersectionObserver = null;
      const katexElementsToProcess = new Set();

      // --- Mermaid関連関数 (ensureMermaid, renderSingleMermaidDiagram, setupMermaidObserver - 変更なし) ---
      // (前回のコードをそのままここに記述)
      async function ensureMermaid() {
          if (mermaidInstance) return mermaidInstance;
          if (!window.mermaidLoadingPromise) {
              window.mermaidLoadingPromise = (async () => {
                  try {
                      const module = await import('https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs');
                      const mermaidAPI = module.default;
                      mermaidAPI.initialize({ startOnLoad: false, theme: 'dark' });
                      console.log('Mermaid loaded.');
                      return mermaidAPI;
                  } catch (error) {
                      console.error('Failed to load Mermaid:', error); window.mermaidLoadingPromise = null; return null;
                  }
              })();
          }
          mermaidInstance = await window.mermaidLoadingPromise;
          return mermaidInstance;
      }
      async function renderSingleMermaidDiagram(preElement) {
          if (!preElement || preElement.dataset.mermaidProcessed !== 'pending') return;
          preElement.dataset.mermaidProcessed = 'processing';
          const codeElement = preElement.querySelector('code');
          const code = codeElement?.textContent?.trim() || '';
          if (!code) { preElement.dataset.mermaidProcessed = 'error'; preElement.textContent = 'Error: Empty code.'; preElement.classList.add('mermaid-error-container'); preElement.classList.remove('mermaid'); return; }
          const mermaidAPI = await ensureMermaid();
          if (!mermaidAPI) { preElement.dataset.mermaidProcessed = 'error'; preElement.textContent = 'Error: Mermaid failed to load.'; if(preElement.classList.contains('mermaid')) {preElement.classList.add('mermaid-error-container'); preElement.classList.remove('mermaid');} return; }
          const id = 'mermaid-' + Math.random().toString(36).substring(2, 9);
          try {
              const { svg } = await mermaidAPI.render(id, code);
              const div = document.createElement('div');
              div.innerHTML = svg; div.classList.add('mermaid-container'); div.dataset.mermaidProcessed = 'done';
              preElement.parentNode?.replaceChild(div, preElement);
          } catch (error) {
              console.error(`Error rendering Mermaid ${id}:`, error, code);
              const errorDiv = document.createElement('div'); errorDiv.classList.add('mermaid-error-container');
              errorDiv.textContent = `Mermaid Error: ${error?.message || String(error)}\n\n${code}`; errorDiv.dataset.mermaidProcessed = 'error';
              preElement.parentNode?.replaceChild(errorDiv, preElement);
          } finally { mermaidElementsToProcess.delete(preElement); }
      }
      function setupMermaidObserver() {
          if (mermaidIntersectionObserver) mermaidIntersectionObserver.disconnect();
          mermaidElementsToProcess.clear();
          const mermaidPres = document.querySelectorAll('pre.mermaid:not([data-mermaid-processed])');
          if (mermaidPres.length === 0) return;
          mermaidPres.forEach(pre => { pre.dataset.mermaidProcessed = 'pending'; mermaidElementsToProcess.add(pre); });
          const observerOptions = { root: null, rootMargin: '200px 0px', threshold: 0.01 };
          mermaidIntersectionObserver = new IntersectionObserver((entries, observer) => {
              entries.forEach(entry => {
                  if (entry.isIntersecting) {
                      const targetPre = entry.target; observer.unobserve(targetPre);
                      renderSingleMermaidDiagram(targetPre).catch(err => console.error("Async mermaid render error:", err, targetPre));
                  }
              });
          }, observerOptions);
          mermaidElementsToProcess.forEach(pre => mermaidIntersectionObserver.observe(pre));
          // console.log(`Observing ${mermaidElementsToProcess.size} Mermaid diagrams.`);
      }


      // --- KaTeX関連関数 (新規追加) ---
      async function ensureKaTeX() {
        // KaTeXライブラリをロード (一度だけ実行)
        if (katexInstance) return katexInstance;
        if (!window.katexLoadingPromise) {
            window.katexLoadingPromise = (async () => {
                console.log('Loading KaTeX...');
                try {
                    // Dynamic import で KaTeX をロード
                    const module = await import('https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.mjs');
                    katexInstance = module.default; // default export を取得
                    console.log('KaTeX loaded.');
                    return katexInstance;
                } catch (error) {
                    console.error('Failed to load KaTeX:', error);
                    window.katexLoadingPromise = null; // 再試行可能に
                    return null;
                }
            })();
        }
        katexInstance = await window.katexLoadingPromise;
        return katexInstance;
      }

      async function renderSingleKaTeXElement(element) {
        // 要素が存在しない、または処理済み/処理中の場合はスキップ
        if (!element || element.dataset.katexProcessed !== 'pending') {
            return;
        }
        element.dataset.katexProcessed = 'processing';
        // console.log(`Processing KaTeX element:`, element);

        // Markdownから抽出されたLaTeXコードを取得 (data属性から)
        const formula = element.dataset.katexFormula || '';
        const displayMode = element.classList.contains('math-block'); // ブロック表示かインライン表示か

        if (!formula) {
            console.warn('KaTeX formula is empty.', element);
            element.dataset.katexProcessed = 'error';
            element.textContent = '[Error: Empty Formula]';
            return;
        }

        const katex = await ensureKaTeX();
        if (!katex) {
            console.error('KaTeX instance is not available. Cannot render formula.');
            element.dataset.katexProcessed = 'error';
            element.textContent = '[Error: KaTeX Load Failed]';
            return;
        }

        try {
            // katex.render() を使って要素の内容を直接書き換える
            katex.render(formula, element, {
                throwOnError: false, // エラー時に例外を投げずにコンソールに出力
                displayMode: displayMode, // ブロック表示かインラインか
                // 他のKaTeXオプションが必要な場合はここに追加
                //例: macros: { "\\RR": "\\mathbb{R}" }
            });
            element.dataset.katexProcessed = 'done'; // 処理完了マーク
            element.classList.remove('katex-pending'); // プレースホルダークラスを削除
            // console.log(`KaTeX formula rendered successfully. Mode: ${displayMode ? 'block' : 'inline'}`);

        } catch (error) {
            // throwOnError: false のため通常ここには来ないが、念のため
            console.error('Error rendering KaTeX formula:', error, '\nFormula:', formula);
            element.dataset.katexProcessed = 'error';
            element.textContent = `[KaTeX Error: ${error.message}]`;
            element.style.color = 'red'; // エラーを目立たせる
            element.classList.remove('katex-pending');
        } finally {
             katexElementsToProcess.delete(element); // 処理対象リストから削除
        }
      }

      function setupKaTeXObserver() {
          // 既存のObserverがあれば切断
          if (katexIntersectionObserver) {
            katexIntersectionObserver.disconnect();
          }
          katexElementsToProcess.clear(); // 古い参照をクリア

          // '.math-block' または '.math-inline' で、まだ処理されていない要素を取得
          // (Markdown側の出力に合わせてセレクタを調整してください)
          const katexElements = document.querySelectorAll('.math-block:not([data-katex-processed]), .math-inline:not([data-katex-processed])');

          if (katexElements.length === 0) {
            // console.log('No unprocessed KaTeX elements found for observer.');
            return;
          }

          // 処理対象としてマークし、リストに追加
          katexElements.forEach(el => {
              el.dataset.katexProcessed = 'pending'; // 処理前マーク
              el.classList.add('katex-pending');   // プレースホルダースタイル適用
              katexElementsToProcess.add(el);
          });

          const observerOptions = {
            root: null,
            rootMargin: '300px 0px 300px 0px', // Mermaidより少し広めに取る？調整可
            threshold: 0.01
          };

          katexIntersectionObserver = new IntersectionObserver(async (entries, observer) => {
            for (const entry of entries) {
              if (entry.isIntersecting) {
                const targetElement = entry.target;
                // console.log('KaTeX element entered viewport:', targetElement);
                observer.unobserve(targetElement); // 一度交差したら監視解除
                // 非同期でレンダリングを実行
                renderSingleKaTeXElement(targetElement).catch(err => {
                   console.error("Async KaTeX render error:", err, targetElement);
                   if(targetElement && targetElement.dataset) targetElement.dataset.katexProcessed = 'error';
                });
              }
            }
          }, observerOptions);

          // 各要素を監視対象に追加
          katexElementsToProcess.forEach(el => {
            katexIntersectionObserver.observe(el);
          });
          // console.log(`Observing ${katexElementsToProcess.size} KaTeX elements.`);
      }


      // --- Copy Button 関数 (addCopyButtons - 変更なし) ---
      function addCopyButtons() {
          document.querySelectorAll('article.prose pre:not(.mermaid):not([data-copy-button-added])').forEach((pre) => {
              const codeEl = pre.querySelector('code'); if (!codeEl) return;
              const btn = document.createElement('button'); btn.textContent = 'Copy';
              btn.className = 'copy-button absolute top-2 right-2 bg-gray-700 text-gray-200 text-xs px-2 py-1 rounded hover:bg-gray-600 opacity-0 group-hover:opacity-100 transition-opacity focus:opacity-100 z-10';
              btn.addEventListener('click', async () => {
                  const textToCopy = codeEl.textContent || ''; if (!navigator.clipboard) { console.warn("Clipboard API not available."); btn.textContent = 'Error'; setTimeout(() => (btn.textContent = 'Copy'), 1500); return; }
                  try { await navigator.clipboard.writeText(textToCopy); btn.textContent = 'Copied!'; } catch (err) { console.error('Failed to copy: ', err); btn.textContent = 'Error'; } finally { setTimeout(() => (btn.textContent = 'Copy'), 1500); }
              });
              pre.classList.add('group'); if (window.getComputedStyle(pre).position === 'static') { pre.style.position = 'relative'; }
              pre.appendChild(btn); pre.dataset.copyButtonAdded = 'true';
          });
      }


      // --- 初期化処理 ---
      function initializePageFeatures() {
         console.log('Initializing page features (Mermaid, KaTeX, Copy Buttons)...');
         setupMermaidObserver(); // Mermaid 初期化
         setupKaTeXObserver();   // KaTeX 初期化 (★追加)
         addCopyButtons();       // コピーボタン 初期化
      }

      // --- イベントリスナー (変更なし) ---
      document.addEventListener('astro:page-load', initializePageFeatures);
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initializePageFeatures);
      } else {
        initializePageFeatures();
      }

    </script>
</body>
</html>
