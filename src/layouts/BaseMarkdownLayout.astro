---
import '../styles/global.pcss';
import { getImage } from 'astro:assets';
import outputGray from '../assets/output_gray.png';
/// <reference types="astro/client" />
import type { MarkdownHeading } from 'astro';
import ExtractLinks from '../components/ExtractLinks.jsx';
import DynamicToc from '../components/DynamicToc.jsx';
import { GoogleFontsOptimizer } from "astro-google-fonts-optimizer";
import Backlinks from '../components/Backlinks.jsx'; // 追加

// --- Props処理 ---
// Markdownレイアウトとして使用する場合、Astroが自動的にheadingsをpropsに含めてくれる
const { headings } = Astro.props as { headings: MarkdownHeading[] };
const rawProps = (Astro.props as any).frontmatter ?? Astro.props;
const {
  title,
  description,
  author,
  tags,
  date,
  pubDate,
  ogImage,
  links, // 追加
} = rawProps as {
  title: string;
  description?: string;
  author?: string;
  tags?: string[];
  date?: string | Date;
  pubDate?: string;
  ogImage?: string;
  links?: { title: string; url: string }[]; // 追加
};

// linksがなければtagsから自動生成
const autoLinks = tags?.map(tag => [
  { title: `Zenn #${tag}`, url: `https://zenn.dev/topics/${tag}` },
  { title: `Qiita #${tag}`, url: `https://qiita.com/tags/${tag}` }
]).flat() ?? [];
const linksToShow = links && links.length > 0 ? links : autoLinks;

// --- OGP/URL関連 (変更なし) ---
const canonicalURL = Astro.url;
const siteName = 'Mekann';
const imagePath = ogImage || '/default-og-image.png';
const absoluteImageUrl = new URL(imagePath, Astro.url.origin).href;

// --- 日付処理 (変更なし) ---
let sourceDate: string | Date | undefined = date ?? pubDate;
let parsedDate: Date | null = null;
let isoDate = '';
if (typeof sourceDate === 'string') {
  try {
    parsedDate = new Date(sourceDate);
    if (isNaN(parsedDate.valueOf())) {
      parsedDate = null;
    } else {
      isoDate = parsedDate.toISOString();
    }
  } catch (e) {
    parsedDate = null;
  }
} else if (sourceDate instanceof Date) {
  if (!isNaN(sourceDate.valueOf())) {
    parsedDate = sourceDate;
    isoDate = parsedDate.toISOString();
  } else {
    parsedDate = null;
  }
}
const validDate = parsedDate instanceof Date;
const displayDate = validDate
  ? parsedDate!.toLocaleDateString('ja-JP', {
      year: 'numeric',
      month: '2-digit',
      day: '2-digit',
    })
  : '';

// 余白調整用の変数は不要になるため削除

// optimizedImg（画像パス）がpropsで渡された場合はWebP最適化
if (rawProps.optimizedImg) {
  const { getImage } = await import('astro:assets');
  const imgMod = await import(rawProps.optimizedImg);
  const optimized = await getImage({ 
    src: imgMod.default ?? imgMod, 
    format: 'avif', 
    quality: 60,
    widths: [400, 800, 1200, 1600], // レスポンシブ対応のための複数サイズ
    densities: [1, 2] // 高解像度ディスプレイ対応
  });
  rawProps.optimizedImg = optimized.src;
}

const optimizedBg = await getImage({ src: outputGray, format: 'avif', quality: 60 });
---

<html lang="ja" class="bg-black">
  <head>
    {/* Head内は変更なし */}
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>{title}</title>
    <base href="/" />
    {description && <meta name="description" content={description} />}
    <meta property="og:title" content={title} />
    {description && <meta property="og:description" content={description} />}
    <meta property="og:url" content={canonicalURL.href} />
    <meta property="og:site_name" content={siteName} />
    <meta property="og:image" content={absoluteImageUrl} />
    <meta property="og:type" content="article" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:site" content="@Mekann2904" />
    <meta name="twitter:creator" content="@Mekann2904" />
    <meta name="twitter:title" content={title} />
    {description && <meta name="twitter:description" content={description} />}
    <meta name="twitter:image" content={absoluteImageUrl} />
    <link rel="preload" as="image" href={optimizedBg.src} />
    <GoogleFontsOptimizer url="https://fonts.googleapis.com/css2?family=Inter:wght@200;400;500;700&display=swap" />
  </head>

  <body class="bg-black text-white text-base bg-faint-image"
    style={`--faint-bg: url('${optimizedBg.src}');`}
  >
    {/* --- Header (変更なし) --- */}
    <header class="fixed inset-x-0 top-0 z-50 bg-black border-b border-white/10 w-full">
      <nav class="flex items-center justify-between px-8 py-5">
        <a href="/" class="text-white font-semibold text-lg">Mekann</a>
        <ul class="flex gap-8 text-sm">
          <li><a href="/" class="text-gray-500 hover:text-white transition">Home</a></li>
          <li class="relative group">
            <button class="text-gray-500 hover:text-white transition flex items-center gap-1">
              Art
              <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
              </svg>
            </button>
            <ul class="absolute right-0 mt-2 min-w-[12rem] max-w-[90vw] bg-black border border-white/10 rounded-lg shadow-lg opacity-0 invisible group-hover:opacity-100 group-hover:visible transition-all duration-200 overflow-x-auto">
              <li><a href="/test/three" class="block px-4 py-2 text-sm text-gray-500 hover:text-white hover:bg-white/5">Knowledge Network 3D</a></li>
              <li><a href="/test/three-1" class="block px-4 py-2 text-sm text-gray-500 hover:text-white hover:bg-white/5">Three.js Light Examples</a></li>
              <li><a href="/test/three-2" class="block px-4 py-2 text-sm text-gray-500 hover:text-white hover:bg-white/5">Water Animation</a></li>
              <li><a href="/test/three-3" class="block px-4 py-2 text-sm text-gray-500 hover:text-white hover:bg-white/5">Three.js 3D Model Demo</a></li>
              <li><a href="/test/three-4" class="block px-4 py-2 text-sm text-gray-500 hover:text-white hover:bg-white/5">Three.js Projector Demo</a></li>
            </ul>
          </li>
          <li><a href="/blog" class="text-gray-500 hover:text-white transition">Blog</a></li>
        </ul>
      </nav>
    </header>

    {/* --- Main Content (3カラムレイアウトに変更) --- */}
    <main class="w-full px-4 sm:px-6 lg:px-8 pt-28 pb-12">
      <div class="grid grid-cols-1 lg:grid-cols-12 lg:gap-x-8">
        
        {headings && headings.length > 1 && (
          <aside class="hidden lg:block lg:col-span-3">
            <div class="sticky top-28">
              <a href="/blog/" class="inline-flex items-center text-gray-500 hover:text-white mb-6 lg:mb-8 no-underline text-base">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18" />
                </svg>
                Back to Blog
              </a>
              <h2 class="text-sm font-bold tracking-wider uppercase text-gray-500 mb-4">On this page</h2>
              <DynamicToc headings={headings} pathname={Astro.url.pathname} client:idle />
            </div>
          </aside>
        )}

        <div class="lg:col-span-6 px-0">
          <article
            class="prose prose-sm prose-invert mx-auto max-w-4xl
                   leading-snug font-jp-sans
                   bg-black/0
                   prose-pre:bg-slate-800 prose-pre:text-gray-100 prose-pre:p-4 
                   prose-pre:rounded-lg prose-pre:overflow-auto prose-pre:my-6
                   prose-code:bg-transparent prose-code:text-inherit
                   prose-img:max-w-full prose-img:h-auto prose-img:rounded-lg
                   prose-img:shadow-lg prose-img:my-6"
          >
            {validDate && (
              <div class="flex flex-col sm:flex-row sm:items-center sm:justify-between text-sm text-gray-500 mb-6 lg:mb-8">
                <time datetime={isoDate}>{displayDate}</time>
                {author && <span class="mt-1 sm:mt-0 sm:ml-4">By {author}</span>}
              </div>
            )}

            <h1 class="text-2xl font-bold text-white mb-8 lg:mb-10">{title}</h1>
            
            {/* 本文のコンテンツがここに表示される */}
            <slot />
          </article>
        </div>
        
        {tags && tags.length > 0 && (
          <aside class="lg:col-span-3 mt-16 lg:mt-0">
            <div class="sticky top-28">
              {/* グラフビューセクション */}
              <div class="mb-8">
                <h2 class="text-sm font-bold tracking-wider uppercase text-gray-500 mb-4">Knowledge Graph</h2>
                <div class="bg-gray-800 border border-gray-600 rounded-lg p-3 h-80 overflow-hidden">
                  <div class="flex items-center justify-between mb-2">
                    <span class="text-xs text-gray-400">Blog Network</span>
                    <button 
                      id="blog-reload-btn" 
                      class="text-xs text-blue-400 hover:text-blue-300 transition-colors"
                      aria-label="Reload graph"
                    >
                      ↻
                    </button>
                  </div>
                  <div id="blog-graph-container" class="w-full h-64 overflow-hidden">
                    <div class="flex items-center justify-center h-full text-gray-500">
                      <div class="text-center">
                        <svg class="w-8 h-8 mx-auto mb-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" />
                        </svg>
                        <p class="text-xs">Loading graph...</p>
                      </div>
                    </div>
                  </div>
                </div>
              </div>

              <h2 class="text-sm font-bold tracking-wider uppercase text-gray-500 mb-4">Tags</h2>
              <div class="flex flex-wrap gap-3 mb-8">
                {tags.map((tag) => (
                  <a
                    href={`/tags/${tag}`}
                    class="bg-gray-800 text-blue-300 hover:bg-gray-700 hover:text-blue-200 px-3 py-1 rounded-full text-sm no-underline transition-colors"
                  >
                    #{tag}
                  </a>
                ))}
              </div>
              <ExtractLinks client:idle />
              <Backlinks slug={Astro.url.pathname.replace(/^\/blog\//, '').replace(/\/$/, '')} client:idle />
            </div>
          </aside>
        )}

      </div>
    </main>

    {/* --- Footer (変更なし) --- */}
    <footer class="bg-black text-gray-400 border-t border-gray-800 py-6 lg:py-8 text-base">
      <div class="container mx-auto text-center text-sm px-6 lg:px-8">
        © {new Date().getFullYear()} {siteName}
      </div>
    </footer>

    {/* グラフ表示用のスクリプト */}
    <script>
      // blog-graph.jsonを読み込んでD3.jsでグラフを表示
      let blogSvg: any, blogSim: any;
      let blogGraphLoaded = false;

      // IntersectionObserver が初めて可視領域を検知したらロード
      const blogContainer = document.getElementById('blog-graph-container');
      const blogReloadBtn = document.getElementById('blog-reload-btn');
      
      if (blogContainer) {
        const blogIo = new IntersectionObserver(
          (entries) => {
            if (entries[0]?.isIntersecting && !blogGraphLoaded) {
              blogGraphLoaded = true;
              initBlogGraph();
              blogIo.disconnect();
            }
          },
          { rootMargin: '100px' }
        );
        blogIo.observe(blogContainer);
      }

      async function initBlogGraph() {
        // @ts-ignore
        const d3 = await import('https://cdn.jsdelivr.net/npm/d3@7/+esm');

        async function buildBlogGraph() {
          if (!blogContainer) return;
          
          // blog-graph.json の読み込み
          let nodes: any[] = [], links: any[] = [];
          try {
            const graph = await fetch('/blog-graph.json').then((r) => r.json());
            nodes = graph.nodes || [];
            links = graph.links || [];
          } catch (e) {
            console.warn('blog-graph.json の読み込みに失敗しました:', e);
            // エラー時の表示
            blogContainer.innerHTML = `
              <div class="flex items-center justify-center h-full text-gray-500">
                <div class="text-center">
                  <svg class="w-6 h-6 mx-auto mb-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L3.732 16.5c-.77.833.192 2.5 1.732 2.5z" />
                  </svg>
                  <p class="text-xs">Graph not available</p>
                </div>
              </div>
            `;
            return;
          }

          // 存在しないノードを参照するリンクを除外
          const nodeIds = new Set(nodes.map((d: any) => d.id));
          links = links.filter((l: any) => nodeIds.has(l.source) && nodeIds.has(l.target));

          const W = blogContainer.clientWidth;
          const H = blogContainer.clientHeight;

          blogSvg = d3.select(blogContainer)
            .append('svg')
            .attr('width', W)
            .attr('height', H)
            .call(
              d3.zoom()
                .scaleExtent([0.3, 3])
                .on('zoom', ({ transform }: any) => inner.attr('transform', transform))
            );

          const inner = blogSvg.append('g');

          const link = inner.append('g')
            .attr('stroke', '#444')
            .attr('stroke-opacity', 0.4)
            .selectAll('line')
            .data(links)
            .join('line')
            .attr('stroke-width', 0.8);

          const node = inner.append('g')
            .selectAll('g')
            .data(nodes)
            .join('g');

          // 現在のページのノードを特定
          const currentPath = window.location.pathname;
          console.log('Current path:', currentPath);
          console.log('Available nodes:', nodes.map((d: any) => d.id));
          
          const currentNode = nodes.find((d: any) => d.id === currentPath);
          console.log('Found current node:', currentNode);
          
          // パスが完全一致しない場合の代替手段
          let targetNode = currentNode;
          if (!targetNode) {
            // 末尾のスラッシュを除去して再試行
            const pathWithoutSlash = currentPath.replace(/\/$/, '');
            targetNode = nodes.find((d: any) => d.id === pathWithoutSlash);
            console.log('Trying without trailing slash:', pathWithoutSlash, 'Found:', targetNode);
          }
          if (!targetNode) {
            // blog/プレフィックスを追加して再試行
            const pathWithBlog = currentPath.startsWith('/blog/') ? currentPath : `/blog${currentPath}`;
            targetNode = nodes.find((d: any) => d.id === pathWithBlog);
            console.log('Trying with blog prefix:', pathWithBlog, 'Found:', targetNode);
          }
          if (!targetNode) {
            // 部分一致で検索
            targetNode = nodes.find((d: any) => d.id.includes(currentPath.replace(/^\//, '')));
            console.log('Trying partial match, Found:', targetNode);
          }

          node.append('circle')
            .attr('r', (d: any) => {
              if (d.id === (targetNode?.id || currentPath)) return 8; // 現在のノード
              return d.ext ? 6 : 4; // 外部リンク or 内部リンク
            })
            .attr('fill', (d: any) => (d.ext ? '#ff9b00' : '#fff'))
            .attr('stroke', (d: any) => d.id === (targetNode?.id || currentPath) ? '#3b82f6' : '#fff')
            .attr('stroke-width', (d: any) => d.id === (targetNode?.id || currentPath) ? 3 : (d.ext ? 1.5 : 0.8))
            .on('click', (_: any, d: any) => { 
              if (!d.ext && d.id.startsWith('/blog/')) {
                location.href = d.id; 
              }
            });

          node.append('text')
            .text((d: any) => d.label.length > 15 ? d.label.substring(0, 15) + '...' : d.label)
            .attr('x', 8)
            .attr('y', 3)
            .attr('fill', '#fff')
            .attr('font-size', '8px')
            .style('pointer-events', 'none')
            .style('text-shadow', '0 0 3px rgba(0,0,0,0.8)');

          blogSim = d3.forceSimulation(nodes)
            .force('link', d3.forceLink(links).id((d: any) => d.id).distance(80))
            .force('charge', d3.forceManyBody().strength(-300))
            .force('collide', d3.forceCollide().radius((d: any) => (d.ext ? 6 : 4) + 10))
            .force('center', d3.forceCenter(W / 2, H / 2))
            .alpha(1)
            .alphaDecay(0.05)
            .on('tick', () => {
              link
                .attr('x1', (d: any) => d.source.x).attr('y1', (d: any) => d.source.y)
                .attr('x2', (d: any) => d.target.x).attr('y2', (d: any) => d.target.y);
              node.attr('transform', (d: any) => `translate(${d.x},${d.y})`);
            });

          // 現在のページのノードを中央に固定（シミュレーション開始後に実行）
          if (targetNode) {
            console.log('Fixing node to center:', targetNode.id);
            // 少し遅延させてシミュレーションが開始された後に固定
            setTimeout(() => {
              targetNode.fx = W / 2;
              targetNode.fy = H / 2;
              blogSim.alpha(0.3).restart(); // シミュレーションを再開
            }, 100);
          } else {
            console.log('No matching node found for current path');
          }

          node.call(
            d3.drag()
              .on('start', (e: any, d: any) => {
                if (!e.active) blogSim.alphaTarget(0.3).restart();
                d.fx = d.x; d.fy = d.y;
              })
              .on('drag', (e: any, d: any) => { d.fx = e.x; d.fy = e.y; })
              .on('end', (e: any, d: any) => {
                if (!e.active) blogSim.alphaTarget(0);
                d.fx = d.fy = null;
              })
          );
        }

        function resizeBlogGraph() {
          if (!blogContainer) return;
          const w = blogContainer.clientWidth;
          const h = blogContainer.clientHeight;
          blogSvg?.attr('width', w).attr('height', h);
          blogSim?.force('center', d3.forceCenter(w / 2, h / 2)).alpha(0.3).restart();
        }

        async function reloadBlogGraph() {
          blogSim?.stop();
          if (blogContainer) {
            blogContainer.replaceChildren();
            await buildBlogGraph();
          }
        }

        await reloadBlogGraph();

        if (blogReloadBtn) {
          blogReloadBtn.addEventListener('click', reloadBlogGraph, { passive: true });
        }
        window.addEventListener('resize', resizeBlogGraph, { passive: true });
      }
    </script>
  </body>
</html>