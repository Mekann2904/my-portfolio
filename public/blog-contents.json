[
  {
    "slug": "download-box",
    "layout": "../../layouts/BaseMarkdownLayout.astro",
    "title": "ダウンロードボックスコンポーネントの使い方",
    "date": "2025-07-16T00:00:00.000Z",
    "description": "ダウンロードボックスコンポーネントの使い方",
    "author": "AI Language Model (Gemini 2.5 Pro)",
    "tags": [
      "components",
      "MDX",
      "Tailwind CSS"
    ],
    "content": "\nimport DownloadBox from '../../components/DownloadBox.jsx'\n\n## ダウンロードボックスコンポーネントの実装概要と使い方\n\n本稿では、Tailwind CSSを用いて作成した再利用可能なダウンロードUIコンポーネント（`DownloadBox.jsx`）の概要と、MDXでの使い方を解説する。\n\n    <DownloadBox\n      fileName=\"output_gray.png\"\n      fileUrl=\"/images/output_gray.png\"\n      client:load\n    />\n\n-----\n\n### 実装概要\n\n  - ファイル名（fileName）とファイルURL（fileUrl）をpropsとして受け取る。\n  - **ファイルサイズ**は自動で取得され、MB単位で表示される。\n  - **description**は任意で指定可能であり、省略した場合は表示されない。\n  - Tailwind CSSでデザインされており、どのMDXファイルでも容易に再利用が可能である。\n  - PDFや画像など、`public/`フォルダに配置した任意のファイルに対応する。\n\n\n-----\n\n### 使い方\n\n1.  **MDXファイルの先頭でインポートする**\n\n    ```mdx\n    import DownloadBox from '../../components/DownloadBox.jsx'\n    ```\n\n2.  **コンポーネントを呼び出す**\n\n    ##### 最小構成（ファイル名とURLのみ）\n\n    ```mdx\n    <DownloadBox\n      fileName=\"sample.pdf\"\n      fileUrl=\"/files/sample.pdf\"\n      client:load\n    />\n    ```\n\n    ##### 説明文を追加する場合\n\n    ```mdx\n    <DownloadBox\n      fileName=\"sample.pdf\"\n      fileUrl=\"/files/sample.pdf\"\n      description=\"サンプルファイルのダウンロード\"\n      client:load\n    />\n    ```\n\n-----\n\n### 注意点\n\n  - 対象ファイル（例: PDF）は`public/`フォルダに配置する必要がある。\n  - `fileUrl`には`/ファイル名`のようにルートパスで指定する。\n  - `description`は省略可能である。\n  - **MDXで使う場合は必ず`client:load`を付与する必要がある。**\n\n-----\n\n以上の手順により、どのMDX記事でも簡単にダウンロードボックスを表示できる。\n\n\n\n### 付録(コンポーネントのソースコード)\n\n\n```jsx\n\nimport { useEffect, useState } from 'react';\n\nfunction formatFileSize(size) {\n  if (!size) return '';\n  const num = Number(size);\n  const units = ['B', 'KB', 'MB', 'GB', 'TB'];\n  let idx = 0;\n  let value = num;\n  while (value >= 1024 && idx < units.length - 1) {\n    value = value / 1024;\n    idx++;\n  }\n  const display = value % 1 === 0 ? value.toString() : value.toFixed(2).replace(/\\.00$/, '').replace(/(\\.[1-9])0$/, '$1');\n  return `${display} ${units[idx]}`;\n}\n\nexport default function DownloadBox({ fileName, fileUrl, description = '' }) {\n  const [fileSize, setFileSize] = useState('');\n\n  useEffect(() => {\n    async function fetchFileSize() {\n      try {\n        const res = await fetch(fileUrl, { method: 'HEAD' });\n        const size = res.headers.get('content-length');\n        setFileSize(formatFileSize(size));\n      } catch (e) {\n        setFileSize('');\n      }\n    }\n    fetchFileSize();\n  }, [fileUrl]);\n\n  return (\n    <div className=\"border border-gray-800 rounded-md p-4 flex items-center gap-4 bg-gray-800 mb-4\">\n      <span className=\"text-2xl text-gray-400\">\n        {/* クリップアイコンSVG */}\n        <svg className=\"w-6 h-6\" fill=\"none\" stroke=\"currentColor\" strokeWidth=\"2\" viewBox=\"0 0 24 24\">\n          <path strokeLinecap=\"round\" strokeLinejoin=\"round\" d=\"M15.172 7l-6.586 6.586a2 2 0 102.828 2.828l7.07-7.07a4 4 0 00-5.657-5.657l-7.071 7.07a6 6 0 108.485 8.486l6.364-6.364\" />\n        </svg>\n      </span>\n      <div className=\"flex-1 min-w-0\">\n        <div className=\"font-semibold text-gray-200\">{fileName}</div>\n        {fileSize && <div className=\"text-xs text-gray-400\">{fileSize}</div>}\n        {description && <div className=\"text-xs text-gray-500\">{description}</div>}\n      </div>\n      <a\n        href={fileUrl}\n        download\n        className=\"inline-flex items-center px-4 py-2 bg-[#6366f1] text-white rounded hover:bg-[#4f46e5] hover:text-white transition\"\n      >\n        {/* ダウンロードアイコンSVG */}\n        <svg className=\"w-5 h-5 mr-2\" fill=\"none\" stroke=\"currentColor\" strokeWidth=\"2\" viewBox=\"0 0 24 24\">\n          <path strokeLinecap=\"round\" strokeLinejoin=\"round\" d=\"M4 16v2a2 2 0 002 2h12a2 2 0 002-2v-2M7 10l5 5m0 0l5-5m-5 5V4\" />\n        </svg>\n        ダウンロード\n      </a>\n    </div>\n  );\n} \n\n```"
  },
  {
    "slug": "mac-smartmontools",
    "layout": "../../layouts/BaseMarkdownLayout.astro",
    "title": "macOSでsmartmontoolsを使ってディスク情報を確認する",
    "date": "2025-07-15",
    "description": "macOSでsmartmontoolsを使ってディスク情報を確認する方法を解説する。",
    "author": "AI Language Model (Gemini 2.5 Pro)",
    "tags": [
      "macOS",
      "smartmontools",
      "ディスク情報",
      "温度情報"
    ],
    "content": "\n\nこの記事では、macOS環境で`smartmontools`というツールをHomebrewを使ってインストールし、接続されているディスクの情報を確認する手順を解説する。特に、外部ディスクの温度情報を取得する例を見ていく。\n\n\n### 1. smartmontoolsのインストール\n\n\n`smartmontools`は、S.M.A.R.T. (Self-Monitoring, Analysis and Reporting Technology) データを通じて、ハードディスクやSSDの健康状態を監視するためのユーティリティだ。macOSでは、Homebrewパッケージマネージャーを使って簡単にインストールできる。\n\n\nまず、以下のコマンドを実行して`smartmontools`をインストールする。\n\n```bash\nbrew install smartmontools\n```\n\n\n**実行結果の解説:**\n\n```\n==> Auto-updating Homebrew...\n...\n==> Auto-updated Homebrew!\nUpdated 2 taps (homebrew/core and homebrew/cask).\n...\n==> Downloading https://ghcr.io/v2/homebrew/core/smartmontools/manifests/7.5\n...\n==> Pouring smartmontools--7.5.arm64_sequoia.bottle.tar.gz\n🍺  /opt/homebrew/Cellar/smartmontools/7.5: 37 files, 2.3MB\n==> Running `brew cleanup smartmontools`...\n```\n\n\n上記の出力から、Homebrewが自動更新された後、`smartmontools`のバージョン7.5が正常にインストールされたことがわかる。インストールされたファイルは`/opt/homebrew/Cellar/smartmontools/7.5`に配置され、インストール後に自動的にクリーンアップが実行されている。\n\n\n### 2. 接続されているディスクの識別\n\n\n`smartmontools`を使ってディスク情報を取得する前に、どのディスクを対象にするか識別しなければならない。`diskutil list`コマンドを使うと、システムに接続されているすべてのディスクとそのパーティション情報を一覧表示できる。\n\n```bash\ndiskutil list\n```\n\n\n**実行結果の解説:**\n\n```\n/dev/disk0 (internal, physical):\n   #:                       TYPE NAME                    SIZE       IDENTIFIER\n   0:      GUID_partition_scheme                        *251.0 GB   disk0\n   1:             Apple_APFS_ISC Container disk1         524.3 MB   disk0s1\n   2:                 Apple_APFS Container disk3         245.1 GB   disk0s2\n   3:        Apple_APFS_Recovery Container disk2         5.4 GB     disk0s3\n\n/dev/disk3 (synthesized):\n   #:                       TYPE NAME                    SIZE       IDENTIFIER\n   ...\n\n/dev/disk4 (external, physical):\n   #:                       TYPE NAME                    SIZE       IDENTIFIER\n   0:      GUID_partition_scheme                        *2.0 TB     disk4\n   1:                        EFI NO NAME                 209.7 MB   disk4s1\n   2:                 Apple_APFS Container disk5         2.0 TB     disk4s2\n\n/dev/disk5 (synthesized):\n   #:                       TYPE NAME                    SIZE       IDENTIFIER\n   0:      APFS Container Scheme -                      +2.0 TB     disk5\n                                 Physical Store disk4s2\n   1:                APFS Volume MSI M482 - Data         37.7 GB    disk5s1\n   2:                APFS Volume MSI M482                10.7 GB    disk5s2\n   ...\n```\n\n\nこの出力から、以下のディスクが確認できる。\n\n*   `/dev/disk0`: 251.0 GBの内部物理ディスク。macOSのシステムがインストールされている。\n*   `/dev/disk4`: 2.0 TBの外部物理ディスク。このディスクはAPFSコンテナ`disk5`を含んでいる。\n*   `/dev/disk5`: `/dev/disk4s2`から合成されたAPFSコンテナで、「MSI M482 - Data」や「MSI M482」といったボリュームが含まれている。\n\n今回は、この外部ディスク`/dev/disk5`の情報を取得することにする。\n\n\n### 3. smartctlで温度情報を取得\n\n\n`smartmontools`に含まれる`smartctl`コマンドを使って、特定のディスクのS.M.A.R.T.情報を取得できる。ディスクの温度情報を確認するには、`-a`オプションで全てのS.M.A.R.T.情報を表示し、`grep -i temperature`で温度に関する行をフィルタリングするのが便利だ。\n\n`smartctl`はディスクに直接アクセスするため、`sudo`コマンドで管理者権限が必要になる。\n\n```bash\nsudo smartctl -a /dev/disk5 | grep -i temperature\n```\n\n\n**実行結果の解説:**\n\n```\nPassword:\nTemperature:                        37 Celsius\nWarning  Comp. Temperature Time:    0\nCritical Comp. Temperature Time:    0\nTemperature Sensor 1:               37 Celsius\n```\n\n\n上記の出力から、外部ディスク`/dev/disk5`の現在の温度は**37℃**であることがわかる。また、温度センサー1の値も同じく37℃を示している。\n\n\n### まとめ\n\n\nこの手順により、Homebrewを使って`smartmontools`をmacOSにインストールし、`diskutil list`でディスクを識別した後、`smartctl`コマンドで外部ディスクの温度情報を正常に取得できた。\n\n\n\n"
  },
  {
    "slug": "obsidian-textlint",
    "layout": "../../layouts/BaseMarkdownLayout.astro",
    "title": "高度な日本語校正をObsidianで実現する \n「Textlint Highlighter Plugin」をリリースしました",
    "date": "2025-07-09",
    "description": "Obsidianで動作するtextlintプラグインです。リアルタイムで文章を校正し、問題箇所をエディタ上でハイライト表示します。",
    "author": "AI Language Model (Gemini 2.5 Pro)",
    "tags": [
      "Obsidian",
      "textlint",
      "プラグイン",
      "日本語校正"
    ],
    "content": "\n\nこの記事はAIによって自動生成されました。\n\n## はじめに\n\nObsidianで日本語の文章を書くすべてのユーザーへ。  \n「表記ゆれをなくしたい」「技術記事の品質を上げたい」  \n「チームのドキュメントルールを統一したい」  \nそんな悩みを解決するプラグインが **Obsidian Textlint Highlighter Plugin** です。\n\nこのプラグインは、Node.js製の強力なテキスト校正ツール \\`textlint\\` をObsidianに統合します。これにより、あなたの文章作成は次のレベルへと引き上げられます。本記事では、その強力な機能と具体的な使い方を解説します。\n\n  \n\n  \n\n---\n\n## 1\\. Textlint Highlighter Pluginとは\n\nこのプラグインは、入力された日本語のテキストを \\`textlint\\` を使ってリアルタイムに解析し、問題点をエディタ上にハイライト表示するものです。これにより、文章の推敲にかかる時間を削減し、より執筆に集中できる環境を構築します。\n\n### textlintとは\n\n[textlint](https://textlint.github.io/) は、プラグイン形式で校正ルールを追加できる、非常に柔軟で強力なテキスト校正エンジンです。例えば、以下のようなチェックを自動化できます。\n\n- **技術文書向けの表記統一** (例: \\`textlint-rule-preset-ja-technical-writing\\`)\n- **敬体（ですます調）と常体（である調）の混在チェック** (例: \\`textlint-rule-no-mix-dearu-desumasu\\`)\n- **表記ゆれのチェック** (例: \\`textlint-rule-prh\\` を利用し、\\`サーバー\\` / \\`サーバ\\` などを統一)\n- **漢字の閉じ開き** (例: \\`textlint-rule-ja-no-mixed-period\\`)\n\nこれらのルールを組み合わせることで、自分だけ、あるいはチームだけの文章執筆規約を構築できます。\n\n---\n\n## 2\\. 主な機能詳解\n\n### 2.1. リアルタイム・ハイライト機能\n\nこのプラグインを有効にすると、エディタ上で文章を記述するそばから自動で校正が実行されます。\\`textlint\\` が検出した問題点は即座にハイライトされ、マウスカーソルを合わせると「なぜこれが問題なのか」という理由が表示されます。\n\nこれにより、修正すべき箇所とその理由が一目瞭然となり、文章を書きながらスムーズに推敲作業を進めることができます。\n\n### 2.2. 柔軟なルールカスタマイズ\n\n本プラグインの真価は、その圧倒的なカスタマイズ性にあります。\n\n### prh.ymlによる表記ゆれチェック\n\n\\`prh.yml\\` というYAMLファイルを使うことで、独自の表記ゆれ辞書を簡単に作成できます。\n\n例: \\`prh.yml\\`\n\n```python\nrules:\n  - expected: \"サーバー\"\n    pattern: \"サーバ\"\n  - expected: \"Web\"\n    pattern: \"/web/i\" # 正規表現も利用可能\n```\n\nこのファイルをプラグイン設定で読み込ませるだけで、「サーバ」と書かれた箇所を自動で検出し、「サーバー」への修正を促してくれます。\n\n### Textlintルールの導入\n\nnpmで配布されている豊富なtextlintルールを導入できます。ただし、別途Node.js環境が必要になる場合があります。  \n例えば、\\`textlint-rule-preset-ja-technical-writing\\` のようなプリセットを導入すれば、技術文書執筆における一般的な規約をまとめて適用できます。\n\n### 2.3. ルール・プリセット管理画面\n\n「たくさんのルールを導入したのはいいけど、今どれが有効になっているか分からない…」  \nそんな悩みを解決するのが、設定画面にある **ルール・プリセット一覧表示機能** です。\n\nプラグイン設定画面を開くと、現在読み込まれている全てのルールが一覧で表示されます。\n\n- ルールのON/OFF: 各ルールの横にあるチェックボックスを切り替えるだけで、一時的にルールを無効化できます。\n- 設定の確認: どのルールファイルから読み込まれているかが明記されており、管理が容易です。\n\nこれにより、プロジェクトや文書の種類に応じて、適用するルールセットを柔軟に切り替えるといった高度な使い方が可能になります。\n\n### 2.4. パフォーマンスへの配慮\n\nリアルタイムで校正処理が走ると、特に長文のファイルではパフォーマンスが心配になります。  \nこのプラグインは、その点も考慮して設計されています。\n\n- キャッシュ機構: 一度校正した結果をキャッシュし、変更があった部分だけを再計算することで、エディタの応答性を損なわないように工夫されています。\n\nこれにより、数万文字を超えるような長大なドキュメントでも、ストレスなく執筆を続けることができます。\n\n> obsidian-textlint-highlighter-plugin  \n> かなりサクサクで、30万字のメモでも動作を確認。 [pic.twitter.com/qlr8s5kJzU](https://t.co/qlr8s5kJzU)\n> \n> — Mekann (@Mekann2904) [July 8, 2025](https://twitter.com/Mekann2904/status/1942542541712416909?ref_src=twsrc%5Etfw)\n\n  \n\n---\n\n## 3\\. インストールと設定\n\n### インストール\n\n1. **\\[推奨\\] BRATを利用する方法**\n\t1. コミュニティプラグイン \\`Obsidian42 - BRAT\\` をインストールします。\n\t2. BRATの設定で \\`Add Beta plugin\\` を選択します。本プラグインのGitHubリポジトリURL (\\` [https://github.com/Mekann2904/obsidian-textlint-highlighter-plugin](https://github.com/Mekann2904/obsidian-textlint-highlighter-plugin/releases)) を入力します。\n\t3. プラグインが自動でインストールされたら、コミュニティプラグイン設定で有効化します。\n2. **手動でインストールする方法**\n\t1. プラグインの [リリースページ](https://github.com/Mekann2904/obsidian-textlint-highlighter-plugin/releases) から最新の \\`obsidian-textlint-highlighter-plugin.zip\\`をダウンロードします。\n\t2. ダウンロードしたファイルをプラグインフォルダ内に配置します。\n\t3. Obsidianを再起動（またはリロード）し、コミュニティプラグイン設定で有効化します。\n\n### 初期設定\n\n1. プラグインを有効化したら、設定画面を開きます。\n2. \\`prh.yml\\` を利用する場合は、ファイルの場所を \\`prh.yml file path\\` に設定します。Obsidian Vault内のパスを指定できます。\n\n---\n\n## 4\\. まとめ\n\n**Obsidian Textlint Highlighter Plugin** は、単なる誤字脱字チェッカーではありません。\\`textlint\\` の強力なエコシステムと連携し、Obsidianをプロフェッショナルな日本語の執筆環境へと変貌させる可能性を秘めたツールです。\n\n- **リアルタイムでの高速なフィードバック**\n- **\\`prh.yml\\` や textlintルールによる無限のカスタマイズ性**\n- **分かりやすいルール管理UI**\n- **長文でも安心のパフォーマンス**\n\nこれらの特徴により、ブロガー、技術者、編集者、学生など、質の高い日本語文章を求めるすべての人にとって、不可欠なプラグインとなるでしょう。\n\nぜひこのプラグインを導入して、より快適で創造的な執筆活動をお楽しみください。\n\n---\n\n## ライセンス\n\nMIT License\n\n  \n\n高度な日本語校正をObsidianで実現する「Textlint Highlighter Plugin」をリリースしました｜Mekann"
  },
  {
    "slug": "why-not-tree",
    "layout": "../../layouts/BaseMarkdownLayout.astro",
    "title": "ツリー構造の限界 ― なぜZettelkastenはリゾームを志向するのか",
    "date": "2025-07-15",
    "description": "静的なツリー構造では捉えきれない複雑な現実と、Obsidianで実践するリゾーム的思考の可能性について論じる。",
    "author": "AI Language Model (Gemini 2.5 Pro)",
    "tags": [
      "ツリー構造",
      "リゾーム",
      "Obsidian",
      "Zettelkasten"
    ],
    "content": "\n## はじめに：「ツリー」という便利な道具とその限界\n\n私たちは物事を考えるとき、無意識に「ツリー構造」というモデルを使っている。組織図やフォルダ階層のように、1つの根から枝分かれさせていく整理方法は、ごちゃごちゃした情報をスッキリさせるのにとても便利だ。Obsidianでノートを取り始めるときも、多くの人がまずこのツリー構造で整理しようとする。\n\nしかし、この方法は本当にベストなのだろうか。複雑な現実を理解し、新しいアイデアを生み出すには、ツリー構造だけでは不十分かもしれない。そこで登場するのが、哲学者ドゥルーズとガタリが提唱した「リゾーム」という考え方だ。\n\nこの記事では、なぜツリー構造に限界があるのか、そしてなぜZettelkasten、特にObsidianが「リゾーム」を目指すのかを、わかりやすく解説する。\n\n### 1. 現実にはたった1つの「根」はない\n\nツリー構造は、必ず「ルートフォルダ」のような、ただ1つの「根」を持つ。しかし、現実の世界の物事に、絶対的な根っこは存在しない。\n\n例えば、「現代社会の孤独」についてノートを作るとする。これを「経済」や「テクノロジー」といった1つのフォルダに入れるのは、あまり意味がない。なぜなら、孤独という問題は、経済、SNS、家族観など、無数の要素が原因になったり結果になったりしながら、複雑に絡み合っているからだ。1つの箱に押し込めた瞬間に、その複雑さは失われてしまう。\n\nリゾーム的なノートの取り方では、ノートを1つの場所に「分類」しない。代わりに、複数の文脈へと自由に「リンク」させる。そうすることで、現実世界の複雑な姿を、そのまま自分の知識ベースに映し取ろうとするのだ。\n\n### 2. 現実は上から下への「階層」ではない\n\nツリー構造は、親から子へ、上から下への一方通行の階層が基本だ。Obsidianの親子リンクもその一種と言える。しかし、現実の世界や知識のつながりは、決して一方通行ではない。\n\n例えば、会社組織では、組織図の上では経営陣がトップだ。しかし、現場の一社員の報告（子ノート）が、会社全体の理念（親ノート）をひっくり返すきっかけになることはよくある。これは、下から上への「ボトムアップ」の力だ。\n\nZettelkastenでも同じことが起きる。ふとしたメモ（子ノート）が、今まで常識だと思っていた大きな概念（親ノート）を覆し、知識全体をアップデートさせることがある。固定的な階層は、こうした創造的な「下剋上」の邪魔になる。現実は、あらゆる方向に線が伸びる、双方向のつながりに満ちている。\n\n### 3. 現実は「違うもの同士」がつながって生まれる\n\nツリー構造は、似たもの同士を同じ枝に集める。リンゴの木にブドウはならない。しかし、歴史的なイノベーションは、全く関係ないと思われていた「違うもの同士」が、偶然つながることで生まれてきた。これこそ、Obsidianの「友達リンク」が持つ大きな力だ。\n\nスマートフォンの誕生が良い例だ。あれは「電話」という木の新しい枝として生まれたのではない。「電話」「PC」「カメラ」「音楽プレイヤー」という、本来は別々の木だったものが、突如つながって生まれたリゾーム的な産物だ。\n\nこれは私たちの思考でも同じである。「生物学のノート」と「マーケティングのノート」が「共生」というキーワードでつながった時、新しいビジネスのアイデアが生まれるかもしれない。リゾーム的なネットワークを育てるということは、こうした「偶然の出会い」をただ待つのではなく、分野を横断するリンクを積極的に張ることで、偶然が起きやすい環境を自分で作ることなのだ。\n\n### 4. 現実は止まっておらず、常に変化する\n\nツリー構造は、一度作ると固定化されやすい。しかし、私たちの知識や考えは、常に変化し、成長し続ける「庭」のようなものだ。\n\n友人関係を「親友」「友人」と分類しても、その関係は明日には変わるかもしれない。ノートの関係性も同じで、新しい発見ひとつで、昨日までのつながりが全く違う意味を持つことがある。\n\nZettelkastenは、完成された「保管庫」ではない。ノートを追加し、リンクをつなぎ変えるたびに、ネットワーク全体が姿を変え、新しい思考を生み出していく、生きているシステムなのだ。ノートに「完成」はなく、常に書き換えられるのを待っている。\n\n### 結論：静的な「地図」から、思考が育つ「庭」へ\n\nつまり、ツリー構造とは「完成された静的な地図」のようなものだ。目的地を知るには便利だが、地図そのものは現実の土地ではない。\n\n私たちが向き合う現実、そして育てるべき知識とは、むしろ「常に変化し続ける、複雑な生態系（庭）」だ。そこでは、アイデアという獣が走り回り、リンクという菌類が地下にネットワークを広げ、予期せぬ洞察という植物が芽を出す。単純化された地図では、これを捉えることはできない。\n\nだから、ObsidianでZettelkastenを実践するときの問いは、「このノートをどこに分類すべきか？」ではなく、「このノートは何を思い出させ、何とつながるか？」に変わる。これは、世界を無理やり「整理」するのをやめ、その複雑さを複雑なまま受け入れるという、大きな態度の転換なのだ。\n\n---\n\n### 思考のコンパスでリゾームを育てる\n\nでは、具体的にどうすればリゾーム的なつながり、特に「友達リンク」を見つけられるのか。そのヒントとなるのが「思考のコンパス」だ。これは、論理的な思考（ツリー）と創造的な思考（リゾーム）を、意図的に引き出す仕組みである。\n\n縦の軸（北-南）：ツリーを育てる思考\n\n* 北（上流/起源）：ノートの「親」を探す行為だ。物事の前提や背景をたどり、階層をさかのぼる。\n* 南（下流/具体化）：ノートの「子」を生み出す行為だ。アイデアを具体例に落とし込み、階層をくだる。\n\nこの縦の軸は、知識を構造化し、深く掘り下げるためのツリー的な思考に対応する。\n\n横の軸（西-東）：リゾームを広げる思考\n\n* 西（強化/拡張）：これこそが「友達リンク」を見つけるための問いだ。「似た事例は？」「他の分野で応用できないか？」と考えることで、分野を横断し、予期せぬつながりを発見する。\n* 東（変革/発展）：「他との違いは？」「どう進化できるか？」と考えることで、既存の枠組みから抜け出す新しい道を探る。\n\nこの横の軸は、知識を水平に広げ、新しいアイデアを生み出すリゾーム的な思考に対応する。\n\n「友達リンクをどう結びつけるか？」という問いに悩んだとき、このコンパスの「西」と「東」へと思考を巡らせることが、具体的な道しるべとなる。"
  }
]