[
  {
    "slug": "astro-image-optimization",
    "layout": "../../layouts/BaseMarkdownLayout.astro",
    "title": "Astroの背景画像の最適化",
    "date": "2025-07-17",
    "description": "Astro v5での背景画像の最適化",
    "author": "AI Language Model (Gemini 2.5 Pro)",
    "tags": [
      "Astro",
      "画像最適化",
      "MDX",
      "Webパフォーマンス"
    ],
    "content": "Astro + MDXで画像を最適化して埋め込む方法\n# 1. 背景画像のWebP最適化対応\nAstroで背景画像をWebP形式で最適化して使うには、のを利用する。のようなローカル画像をimportし、frontmatterで以下のように記述する。\nには最適化されたWebP画像のURLが格納される。これをのstyle属性でカスタムプロパティにセットし、CSSで背景画像として利用する。\n# 2. CSSによる背景画像表示の仕組み\nではで背景画像を表示する設計になっている。でカスタムプロパティを参照し、で薄く表示する。bodyタグにはとを指定する必要がある。\n# 3. 画像最適化のビルド・出力の流れ\nAstroの画像最適化は本番ビルド（）時のみ有効だ。開発サーバー（）では最適化画像は生成されない。ビルド後、のようなファイルが生成されていることを確認する。で本番プレビューを行い、画像が正しく配信されているかをチェックする。\n# 4. 背景画像が表示されない場合のトラブルシュート\nの定義が本番ビルドにバンドルされているか確認する。\nDevToolsでが生成されているか、スタイルが正しいか確認する。\n画像URLが有効か直接アクセスして確認する。\nなので背景が非常に薄く見える。必要に応じて一時的ににして確認する。\n画像が表示されない場合、がインストールされているか、Astroのバージョンが3以上か、キャッシュが残っていないかも疑う。\n# 5. その他の注意点\nパッケージがインストールされていないと画像最適化は動作しない。\nAstroのバージョンが3以上であることを確認する。\n画像最適化やCSSのimport漏れ、キャッシュのクリアも重要なポイントだ。\n--\n# 参考リンク\nAstro公式: 画像最適化ガイド"
  },
  {
    "slug": "command-palette-explanation",
    "layout": "../../layouts/BaseMarkdownLayout.astro",
    "title": "React Hooksを駆使した高機能コマンドパレットの実装",
    "date": "2025-07-17",
    "description": "React Hooksを活用し、キーワード・タグ・ユーザーによるAND検索やサジェスト機能を備えた高機能なコマンドパレットを実装する方法を解説する。",
    "author": "AI Language Model (Gemini 2.5 Pro)",
    "tags": [
      "React",
      "全文検索",
      "Hooks"
    ],
    "content": "## はじめに\nVS CodeやRaycast、Slackなどで見られる「コマンドパレット」は、現代的なアプリケーションに欠かせないUIとなりつつある。これはキーボードショートカット（多くは  や ）で検索窓を呼び出し、さまざまな操作を高速に実行できる便利な機能だ。\n本記事では、ブログサイトに以下のような高機能なコマンドパレットを実装する方法を、React Hooksを活用して解説する。\nキーボード主体の操作: ショートカット起動、ESCキーでのクローズ\n高度なAND検索: キーワード、タグ（）、ユーザー（）の組み合わせ\n入力サジェスト: タグやユーザー名のインテリジェントな補完\nヘルプ機能:  入力で使い方を表示\n--\n## アーキテクチャと設計思想\n効率的な実装のためには、まず全体の構造と設計のポイントを理解しておく必要がある。\n### コンポーネントの全体像\n今回の実装は、役割の異なる2つのコンポーネントで構成されている。\n1.  ****\n    コマンドパレットの表示・非表示を管理し、起動トリガー（ボタンやショートカットキー）を提供するラッパー。\n2.  ****\n    検索ロジック、サジェスト、UIなど、コマンドパレット本体のすべての機能を担う中核コンポーネント。\n### なぜ記事データをJSONで取得するのか？\nこの実装の核心は、クライアントサイドで全記事データを一括で取得し、検索処理を行う点にある。 は、マウント時に  というファイルを取得する。\nこの設計には、主に3つのメリットがある。\n高速な全文検索: サーバーとの通信なしに、手元にある全データに対して即座にフィルタリングを実行できる。これにより、入力のたびにリアルタイムで結果が更新される快適なUXが実現する。\n静的サイトとの親和性: AstroやNext.jsなどのフレームワークでは、ビルド時に全記事データをまとめて一つのJSONファイルとして出力することが容易。APIサーバーが不要で、CDNから高速に配信できる。\nシンプルな実装: サーバーサイドの複雑な検索APIを実装する必要がなく、フロントエンドのロジックに集中できる。\n--\n## 実装の詳細\nここからは、具体的な実装をコンポーネントごとに解説する。\n### ラッパーコンポーネント（）\nこのコンポーネントの責務はシンプルで、「表示状態の管理」と「起動インターフェースの提供」だ。\n状態管理:  で表示状態（）を管理する。 は、子コンポーネントに渡す関数の再生成を防ぐための最適化である。\nショートカット登録:  で  イベントを監視し、 が押されたらパレットを表示する。クリーンアップ関数でイベントリスナーを解除するのは、メモリリークを防ぐための重要な作法である。\n--\n### コマンドパレット本体（）\nこのコンポーネントが機能の中核をなす。ロジックを「状態管理」「クエリ解析と検索」「サジェスト機能」の3ステップで解説する。\n#### 1. 状態管理とデータ取得\nまず、コンポーネントが必要とする全ての状態を定義し、前述の通り記事データを取得する。\n#### 2. クエリ解析と全文検索\n入力されたクエリを解析し、AND条件で記事をフィルタリングする検索機能の心臓部である。\nクエリ解析: 入力文字列を空白で分割し、 や  の接頭辞をもとに、タグ・ユーザー・キーワードの3種類に分類する。\n全文検索: キーワードは、記事の , ,  を連結した一つの大きな文字列（）に対して検索される。\nAND検索:  を利用し、指定された全ての条件（タグ、ユーザー、キーワード）を満たす記事のみを抽出する。\n最適化: この重いフィルタリング処理は  でメモ化し、依存する値が変更されたときのみ再計算されるようにしてパフォーマンスを確保している。\n#### 3. サジェストとキーボード操作\n入力中のトークンを検出し、候補を提示してキーボードで補完できるようにすることで、UXを大幅に向上させている。\n候補検出:  内で、正規表現  を使い、入力中の  や  形式のトークンを的確に捉える。\n候補提示: 全タグ・ユーザーリストから部分一致で候補を絞り込み、Stateを更新してUIに反映する。\nキーボード操作:  や  キーでサジェストを確定し、クエリを補完する。 でブラウザのデフォルト動作を抑制するのがポイントである。\n--\n## まとめと今後の展望\n本記事では、React Hooksを効果的に組み合わせることで、高機能かつパフォーマンスに優れたコマンドパレットを実装する方法を解説した。\n/ で状態とDOM参照を管理\n でデータ取得やイベントリスナなどの副作用を処理\n/ で重い処理や関数をメモ化し、パフォーマンスを最適化\nこれらの基本的なHooksを適切に使い分けることで、複雑なUIでも宣言的で見通しの良いコードを書くことができる。\nこの実装をベースとして、さらに以下のような拡張も考えられる。\nファジー検索:  などのライブラリを導入し、より柔軟なあいまい検索に対応する。\n結果のキーボード操作: 矢印キーで検索結果自体を選択し、でページ遷移できるようにする。\n検索対象の拡張: カテゴリやその他のメタデータも検索対象に加える。\nWebサイトに強力な検索機能と優れた操作性を提供したい場合、この実装は良い出発点となる。"
  },
  {
    "slug": "compress-astro",
    "layout": "../../layouts/BaseMarkdownLayout.astro",
    "title": "Astroにビルドファイル圧縮を導入する",
    "date": "2025-07-17",
    "author": "AI Language Model (Gemini 2.5 Pro)",
    "tags": [
      "Astro",
      "ファイル圧縮",
      "Webパフォーマンス"
    ],
    "description": "AstroでHTML・CSS・JS・画像を自動圧縮して通信量と表示速度を大幅に改善する方法を解説します。",
    "content": "AstroでGoogle Fontsを最適化・インライン化する方法\n## Astroで@playform/compressを導入しビルドファイルを圧縮する方法\nAstroプロジェクトにおいて、インテグレーションを導入すると、ビルド時にHTML、CSS、JavaScript、画像といった静的ファイルを自動的に圧縮できる。これにより、Webサイトのパフォーマンスに直結する通信データ量を削減し、表示速度の向上が期待できる。\n----\n## なぜファイル圧縮が重要なのか？\nWebサイトのパフォーマンスは、ユーザー体験に極めて大きな影響を与える。特にページの読み込み速度は重要であり、その速度を決定づける要因の一つが転送されるファイルサイズである。\nサーバーからブラウザへ送信されるファイルサイズが小さいほど、ネットワーク経由でのダウンロード時間が短縮される。これは、特にモバイル回線などの低速なネットワーク環境下で顕著な効果を発揮する。は、この圧縮プロセスをビルド時に自動で行い、最適化されたファイルを生成するためのツールである。\n----\n## @playform/compressの主な機能\nこのインテグレーションは、ビルドプロセス（）中に以下の処理を実行する。\n  * テキストファイルの圧縮: HTML、CSS、JavaScriptファイルをGzipとBrotli形式で圧縮し、それぞれとの拡張子を持つファイルを生成する。BrotliはGzipよりも高い圧縮率を誇るモダンな圧縮アルゴリズムである。\n  * 画像ファイルの最適化: フォルダ内の画像（JPG, PNG, WebP, SVGなど）を含め、サイト内の画像を画質を極力維持しながらファイルサイズを削減する。これはAstro標準の画像機能が主に配下を対象とするのに対し、フォルダ内の画像も自動で処理する点で大きな利点となる。\n----\n## 導入手順\n### 1\\. パッケージの追加\nAstroにはインテグレーションを簡単に追加するためのコマンドが用意されている。以下のコマンドを実行するのが最も簡単で推奨される方法だ。\nこのコマンドを実行すると、のインストールと、設定ファイルへの記述が対話形式で自動的に行われる。\n### 2\\. 設定内容の確認\nコマンド実行後、には以下のようにインテグレーションが追加されていることを確認する。\n の引数にオプションを渡すことで、圧縮の挙動をカスタマイズすることも可能だ。\n----\n## 注意点と補足事項\n  * サーバー側の設定: はビルド時にやファイルを生成するだけである。実際に圧縮されたファイルがブラウザに配信されるためには、サーバー側で適切な設定が必要となる。例えば、NginxやApache、またはVercelやNetlifyといったホスティングサービスが、リクエストヘッダ（）に応じて適切な圧縮ファイルを返すように設定されている必要がある。多くのモダンなホスティングサービスでは、この設定は自動で行われる。\n  * Astro 4.5以降の圧縮機能との違い: Astro 4.5から、ミドルウェアを利用してリクエスト時に動的にレスポンスを圧縮する機能が実験的に導入された。はビルド時に静的ファイルを事前に圧縮しておく方式であり、サーバーの負荷を低減できるという利点がある。\n  * 圧縮対象の制御: 特定の画像を圧縮したくない場合や、圧縮率を細かく制御したい場合は、このインテグレーションの機能だけでは不十分な可能性がある。その際は、他の画像最適化ツールとの使い分けを検討する必要がある。\n  * ビルド後の確認: 導入後は、必ずコマンドを実行してディレクトリ内にやファイルが生成されているか、また画像の画質が許容範囲内であるかを確認することが重要だ。\n----\n## 参考リンク\n  * GitHub: playform/compress\n  * Astro公式ドキュメント: インテグレーション"
  },
  {
    "slug": "divergences",
    "layout": "../../layouts/BaseMarkdownLayout.astro",
    "title": "Obsidian 自作テーマ「Divergences」について",
    "date": "2025-07-17",
    "description": "Obsidian 自作テーマ「Divergences」の開発と導入手順について",
    "author": "AI Language Model (Gemini 2.5 Pro)",
    "tags": [
      "Obsidian",
      "自作テーマ",
      "CSS",
      "Divergences"
    ],
    "content": "# 1. 緒言\n本レポートは、多機能ノートアプリ「Obsidian」において、ユーザー体験を向上させるためのインターフェースのパーソナライズ、具体的にはカスタムテーマ「Divergences」の開発から導入に至る全過程を記録し、その技術的詳細と知見を報告するものである。\nObsidianは高いカスタマイズ性を有するが、既存のテーマでは個々のユーザーが求める最適な作業環境を完全に満たすことが難しい場合がある。この課題認識が、本プロジェクトの出発点となった。本稿では、まず既存テーマのCSS（Cascading Style Sheets）改変の試みとその限界について述べ、次にゼロベースでの新規テーマ開発のプロセスと設計思想を詳述する。最終的に、完成したテーマ「Divergences」の具体的な導入手順と設定方法を網羅的に解説する。\n# 2. 既存テーマの改変と課題\n## 2.1. カスタマイズの動機と初期段階\n開発の初期段階では、既存のコミュニティ製テーマ「AnuPpuccin」（https://github.com/AnubisNekhet/AnuPpuccin) をベースとした。このテーマは優れたデザインであったが、長期間使用する中で「UIをさらに自身の作業に最適化したい」という要求が強まった。この要求が、カスタムCSSを用いた部分的な改変に着手する直接的な動機となった。\n当初の作業は、サイドバーの背景色やフォントの変更といった単純なものであった。しかし、Obsidianの内部構造は想定以上に複雑であり、各要素は詳細なクラスやセレクタによって制御されていた。\n## 2.2. 技術的課題\n改変作業において、いくつかの技術的課題が明らかになった。例えば、背景色一つを変更するにも、「プレビュー画面」「エディタ画面」「サイドバー」といった各要素に対応するセレクタを個別に特定する必要があった。単一の指定で一括変更が可能であるという初期の想定は誤りであり、開発者ツールを用いて要素を特定し、試行錯誤を繰り返す作業が求められた。\nさらに、ベーステーマのCSSは多層的に定義されており、レイアウト、配色、ホバーエフェクトなどが複雑に絡み合っていた。このため、一部の変更が予期せぬ別の要素に影響を及ぼすという事態が頻発した。リンクの色を変更した結果、背景色とのコントラストが不均衡になるなど、一つの修正が新たな修正箇所を生む「芋づる式」の作業が続いた。この過程はパズル的な面白さを持つ一方で、抜本的なデザイン変更の困難さを示唆していた。\n## 2.3. 自作テーマ開発への移行\n既存テーマの改変を続ける中で、以下のような具体的な改善要求が次々と生じた。\n* サイドバーのフォルダ間隔を詰め、情報の一覧性を向上させたい。\n* 見出しをより大きくし、視認性を高めたい。\n* リストの行間を広げ、可読性を改善したい。\nこれらの要求を満たすためには、既存のコードを追いかけるよりも、ゼロから自身の設計思想に基づいてテーマを構築する方が、効率的かつ自由度が高いと結論付けた。この結論が、次章で述べる新規テーマ「Divergences」の開発へと繋がった。\n# 3. 新規テーマ「Divergences」の開発\n## 3.1. 開発理念と目標\nテーマ「Divergences」の開発にあたり、最も重視した目標は「使っていて楽しい」という主観的な体験価値の創出である。これを実現するため、ダークブルーとパープルを基調とした幻想的な配色を採用した。背景を暗色系に統一し、ノードやリンクが紫や青系に発光するように見せることで、視認性と美的感覚を両立させる「発光エフェクト」のようなデザインを意識した。\n同時に、Obsidianが本来持つPKM（パーソナル・ナレッジ・マネジメント）ツールとしての実用性を損なわないよう、情報の整理しやすさとデザイン性のバランスを重視した。さらに、ユーザーが自身の好みに合わせて容易に調整できるよう、高いカスタマイズ性を持つ設計とした。\n## 3.2. 開発手順\n開発は以下の4つの手順で進められた。\n1.  ベーススタイルの定義: テーマの全体的な雰囲気（落ち着いた色合いか、ポップな色味か）、背景色、フォントなどの基本方針を決定した。\n2.  ObsidianのCSS構造の理解: Obsidianのデフォルトスタイルを解析し、上書きすべき要素と方法を特定した。特にテーマの印象を大きく左右する透過度などの視覚効果については、調整すべき箇所を事前に洗い出した。\n3.  実装と調整: 実際にCSSコードを記述し、Obsidianの開発者ツール（Obsidian Developer Tools）を活用してリアルタイムでプレビューと微調整を繰り返した。要素の階層構造を調査しながら、段階的に理想形へと近づけた。\n4.  テーマの公開: 自身が「使いやすい」と判断できる水準に達した時点で、GitHubにリポジトリを作成してテーマを公開した。これにより、外部からのフィードバックを得る機会が生まれ、テーマの継続的な改善に繋がると考えた。\n# 4. 「Divergences」の導入手順\n本章では、開発したテーマ「Divergences」をユーザーが自身のObsidian環境に導入するための具体的な手順を詳述する。\n## 4.1. Step 1: テーマのインストール\n1.  テーマファイルの入手:\n    GitHubリポジトリ（https://github.com/Mekann2904/obsidian-divergences-theme）にアクセスする。画面右側の「Releases」セクションから最新版の  をダウンロードする。\n2.  テーマフォルダへの配置:\n    Obsidianの「設定」→「外観」タブを開き、「テーマ」項目にあるフォルダアイコンをクリックしてテーマフォルダ（）にアクセスする。ダウンロードしたzipファイルを解凍し、中身のフォルダをこのthemesフォルダ内に配置する。\n3.  テーマの有効化:\n    Obsidianの「外観」設定に戻り、「テーマ」のドロップダウンメニューから「Divergences」を選択する。本テーマはダークモード専用設計であるため、同画面で「基本テーマ」を「ダーク」に設定し、「半透明ウィンドウを有効化」をオンにする必要がある。\n## 4.2. Step 2: 関連プラグインの導入\nテーマの全機能を利用するためには、以下のコミュニティプラグインの導入が必須または推奨される。\n  * obsidian-style-settings（必須）:\n    テーマの詳細なデザイン（配色、背景設定、エフェクト等）をGUIで調整するためのプラグイン。\n  * obsidian-local-vault-server（推奨）:\n    ローカルPC上の画像を安全にObsidianの背景として利用するためのプラグイン。\n上記プラグインは、「設定」→「コミュニティプラグイン」から検索し、インストールと有効化を行う。\n## 4.3. Step 3: カスタム背景の設定\n1.  「設定」→「Style Settings」（プラグイン設定項目）を開き、「Divergences」のセクションを選択する。\n2.  「カスタム背景を有効化」をオンにする。\n3.  「画像のURLを設定」欄に、背景として使用したい画像のURL（例: ）を入力する。\n4.  「フィルターの設定」項目で、背景の透明度やぼかし効果を任意の値に調整する。\n5.  背景が表示されない場合は、URLの正当性（ブラウザで直接開けるか）、フィルター設定、Obsidianの再起動などを確認する。\n# 5. 考察\n一連のテーマ開発を通じて得られた最大の収穫は、Obsidianの内部構造、特にDOM（Document Object Model）とCSSの関連性についての深い理解である。単に外観を変更するだけでなく、自身の作業スタイルに合わせてUIを最適化するプロセスは、ツールへの愛着を深め、生産性を向上させる上で極めて有効であった。\n既存テーマの改変から始めたことにより、CSSの継承や詳細度の概念を実践的に学ぶことができた。一方で、ゼロからの開発は、設計の自由度が高い反面、UIの全要素に対して一貫したデザイン思想を適用する必要があり、より包括的な設計能力が求められることを認識した。この経験は、今後のプラグイン開発やさらなるカスタマイズへの大きな足がかりとなるだろう。\n# 6. 結論\n本プロジェクトは、Obsidianの既存テーマに対する個人的な改善要求から始まり、最終的に完全オリジナルのカスタムテーマ「Divergences」を開発・公開し、その導入方法を確立するに至った。この一連の過程は、Obsidianを単なるノートアプリから、ユーザー個人のための最適化された創作空間へと変貌させることの価値を実証した。\n本レポートが、同様にObsidianのカスタマイズに挑戦しようとする他のユーザーにとって、一つの実践的な指針となることを期待する。\n----\n補遺：フィードバックの要請\n本テーマに関する質問や改善提案、不具合報告は歓迎する。また、本テーマを使用した感想などを、X（旧Twitter）上でハッシュタグ  および  を付与して投稿いただければ、開発の励みとなる。"
  },
  {
    "slug": "download-box",
    "layout": "../../layouts/BaseMarkdownLayout.astro",
    "title": "ダウンロードボックスコンポーネントの使い方",
    "date": "2025-07-16T00:00:00.000Z",
    "description": "ダウンロードボックスコンポーネントの使い方",
    "author": "AI Language Model (Gemini 2.5 Pro)",
    "tags": [
      "components",
      "MDX",
      "Tailwind CSS"
    ],
    "content": "# ダウンロードボックスコンポーネントの実装概要と使い方\n本稿では、Tailwind CSSを用いて作成した再利用可能なダウンロードUIコンポーネント（）の概要と、MDXでの使い方を解説する。\n    \n----\n## 実装概要\n  - ファイル名（fileName）とファイルURL（fileUrl）をpropsとして受け取る。\n  - **ファイルサイズ**は自動で取得され、MB単位で表示される。\n  - **description**は任意で指定可能であり、省略した場合は表示されない。\n  - Tailwind CSSでデザインされており、どのMDXファイルでも容易に再利用が可能である。\n  - PDFや画像など、フォルダに配置した任意のファイルに対応する。\n----\n## 使い方\n1.  **MDXファイルの先頭でインポートする**\n    \n2.  **コンポーネントを呼び出す**\n    ##### 最小構成（ファイル名とURLのみ）\n    \n    ##### 説明文を追加する場合\n    \n----\n## 注意点\n  - 対象ファイル（例: PDF）はフォルダに配置する必要がある。\n  - にはのようにルートパスで指定する。\n  - は省略可能である。\n  - **MDXで使う場合は必ずを付与する必要がある。**\n----\n以上の手順により、どのMDX記事でも簡単にダウンロードボックスを表示できる。\n## 付録(コンポーネントのソースコード)"
  },
  {
    "slug": "generate-graph",
    "layout": "../../layouts/BaseMarkdownLayout.astro",
    "title": "サイト構造を解析し、関係グラフを生成する",
    "date": "2025-07-18",
    "description": "build時にサイト構造を解析し、jsonファイルにして関係グラフを生成する",
    "author": "AI Language Model (Gemini 2.5 Pro)",
    "tags": [
      "Astro",
      "グラフ構造",
      "json"
    ],
    "content": "#  コード解説：サイト構造を解析し、関係グラフを生成する\nこのスクリプトは、静的に生成されたウェブサイトのディレクトリ内にある全HTMLファイルを解析し、ページ間のリンク構造を抽出して、それをグラフデータ（ノードとリンク）としてJSONファイルに出力するものである。\n具体的には、サイト全体のページ相関図である  と、ブログ記事間の関連に特化した  の2つのファイルを生成する。これにより、サイトの構造を可視化したり、ページ間の関連性を分析したりすることが可能になる。\n## 全体構成\nスクリプトは主に3つの非同期関数で構成されている。\n1.  : サイト全体のグラフデータ () を生成する。\n2.  : ブログ記事のみに絞ったグラフデータ () を生成する。\n3.  : 上記2つの関数を順次実行し、スクリプト全体を動かすエントリーポイント。\n## 使用モジュール\nスクリプトの冒頭で、Node.jsの標準モジュールと外部ライブラリをインポートしている。\n  * : ファイルシステムを操作するためのモジュール。ファイルの読み書きを非同期（ベース）で行うために使用する。\n  * : ファイルパスやディレクトリパスを扱うためのモジュール。OS間の差異（Windowsの  とUnix系の ）を吸収し、パスの結合や正規化を行う。\n  *  (): globパターン（例: ）を使って、条件に一致するファイルやディレクトリを高速に検索するための外部ライブラリ。\n----\n# 関数: サイト全体のグラフ生成\nこの関数がスクリプトの中核を担い、サイト全体のページとリンクの関係を解析する。\n## 1. ファイルの探索と初期化\n  * で、ビルド成果物が格納されているディレクトリの絶対パスを取得する。\n  * を使い、ディレクトリ内の全てのを再帰的に検索する。オプションにより、結果は絶対パスの配列として得られる。\n  * （グラフのノード、つまり各ページ）と（ノード間をつなぐエッジ、つまりリンク）を格納するための空の配列を初期化する。\n## 2. フィルタリングルールの定義\nグラフに含めるリンクを細かく制御するため、許可リストと除外リストをオブジェクトで定義している。は値の重複を許さず、特定の要素が含まれているかを高速にチェック（）できるため、このような用途に適している。\n  * 許可リスト (): 特定のページ（例: ホーム ）へのリンクを、どのページから許可するかを定義する。これにより、ヘッダーのロゴなど、全ページから張られる共通リンクをグラフから除外しつつ、意図したページからのリンクは残すことができる。（※現在のコードではこの許可リストは実際には使われていないが、将来的な拡張のために用意されていると考えられる。）\n  * 除外対象 (, , ): ナビゲーションメニューのリンクや、画像・CSS・JavaScriptといったアセットファイルへのリンクなど、ページの主題とは直接関係のないリンクをグラフから除外するために使う。\n## 3. HTMLファイルのループ処理と解析\n配列をループし、1つ1つのHTMLファイルを処理していく。\n### パスの正規化\n  * で、ディレクトリから見たファイルの相対パスを取得する。\n  * Astroなどのフレームワークでは、ページは通常  という構造で生成されるため、でディレクトリ名を取得し、それをページパスとしている。\n  * は、Windows環境でパス区切り文字が  になることを想定し、URLとして扱えるように  へ統一している。\n  * ルートディレクトリのはパスが  となるため、 に変換している。\n### ノードの追加\n正規化されたをとして、グラフのノードを配列に追加する。にはページ名が表示されるようにし、で内部リンクのノードであることを示す。\n### リンクの抽出と解析\n  * でHTMLファイルの中身を文字列として読み込む。\n  * と正規表現を使い、属性を持つ全てのリンク（タグなど）を抽出する。\n  * この正規表現  は秀逸で、以下の3つの形式の属性に対応している。\n    1.   （ダブルクォート）\n    2.   （シングルクォート）\n    3.   （クォートなし）\n### リンクの種別判定とフィルタリング\n抽出したの値ごとに、外部リンクか、アセットか、内部リンクかを判定し、必要なものだけを配列に追加する。\n  * 外部リンク:  で判定。外部リンクもグラフのノードとして追加し、 のリンクで結ぶ。\n  * アセット:  や  を使って、画像やCSSなどのアセットを除外する。これらはページ間の関係性を示さないため不要。\n  * 内部リンク:\n      *  で始まる絶対パス、 や  で始まる相対パスを正しく解釈する。相対パスは  を使って、現在のページパスを基準に絶対パスへ変換する。\n      * 自分自身へのリンク（自己ループ）や、に含まれるナビゲーションリンクは除外する。\n      * 全てのチェックを通過した有効な内部リンクのみを、 のようにして配列に追加する。\n## 4. 重複排除とJSON書き出し\n  * ノードの重複排除: ループ処理の中で、同じ外部リンクが複数のページから参照されると、配列に重複して追加されてしまう。そこで  というテクニックを使い、をキーにしてノードをMapに格納することで重複をなくしている。最後に  でMapの値を配列に戻し、一意なノードリストを得る。\n  * JSON書き出し: で出力先のディレクトリを（なければ）作成し、で最終的なグラフデータを  として書き出す。の第3引数にを指定することで、人間が読みやすいようにインデントされたJSONが生成される。\n----\n# 関数: ブログ専用グラフ\nこの関数は関数とほぼ同じロジックだが、ブログに関連するページとリンクのみを対象とする点が異なる。\n関数との主な違い:\n  * 探索対象:  のように、探索範囲をディレクトリ配下に限定している。\n  * 除外ルール: 除外対象となるナビゲーションパスが  のみになるなど、ブログに特化したシンプルなルールになっている。\n  * ラベル生成: ノードのラベルを生成する際に、 とすることで、共通の接頭辞  を取り除き、記事名だけを表示するようにしている。\n  * 出力ファイル: 結果は  に書き出される。\nこれにより、ブログ記事同士や、記事からタグへのリンクといった、より密な関係性だけを抽出したグラフを得ることができる。\n----\n# 関数と実行\nこの部分はスクリプトの実行を管理する。\n  * 関数内で、とをを使って直列に実行する。\n  * で、処理中に何らかのエラーが発生した場合にそれをコンソールに出力し、で異常終了を知らせる。\n## まとめ\nこのスクリプトは、静的サイトジェネレータ（Astroなど）でビルドした後のHTMLを解析し、サイトの構造を把握するための強力なツールである。フィルタリングルールが柔軟に記述されているため、様々な要件に合わせてカスタマイズが可能だ。生成されたJSONファイルは、D3.jsやvis-networkなどのライブラリと組み合わせることで、ウェブ上でインタラクティブなネットワークグラフとして可視化することに利用できる。"
  },
  {
    "slug": "git-hooks",
    "layout": "../../layouts/BaseMarkdownLayout.astro",
    "title": "Git hooksの実践ガイド",
    "date": "2025-09-08",
    "description": "Git hooksの実践ガイド",
    "author": "Mekann",
    "tags": [
      "Git",
      "GitHub",
      "Git hooks"
    ],
    "content": "このガイドはNode.jsプロジェクト（単体/モノレポ両対応）を対象とし、GitフックをHuskyで一元管理し、コミットやプッシュ時の品質を自動担保することを目的とする。\n--\n# 0. TL;DR（最短セットアップ）\n以下は、Huskyとlint-stagedを使った最短セットアップ手順である。\n--\n# 1. Git hooks と Husky の関係\nGit hooksとは、Gitが用意するや、といったイベント駆動のスクリプトである。従来、これらはディレクトリに直接シェルスクリプトを記述して利用されていたが、このディレクトリはVCSの管理外であるためチームでの共有が困難で、移植性にも課題があった。Huskyは、ディレクトリをリポジトリにコミットしてチームで共有し、スクリプトを通じてGitのhooksPathに連携させることで、この問題を解決する仕組みである。\n仕組みの要点として、が実行されるとが走り、Huskyが内にランチャーを設置する。その後、各Gitフックがトリガーされると、対応する内のシェルが起動され、プロジェクトのNode.jsや関連ツールを使った検証処理が実行される流れとなる。\n--\n# 2. よく使うフックの実務パターン\n実務では、各フックを役割分担させて利用することが多い。フックでは、変更されたファイルに対してフォーマット、リンター、型チェック、軽量なユニットテストなど、即座にフィードバックできる処理を実行する。フックは、Commitlintなどを用いてコミットメッセージが規約に沿っているかを検証する。フックでは、E2Eテストやビルドなど、より重量級の検証を必要に応じて行うが、処理時間が長すぎる場合はCIに委譲するのが賢明である。また、やフックでは、依存関係の差分に応じた自動インストールや生成物の同期といった処理を自動化することも可能である。原則として、ローカルでのフックは高速な差分検証を中心に据え、重い全体チェックはCIに任せることで、開発者体験と品質保証のバランスを取ることが最適解となる。\n--\n# 3. lint-staged 連携の鉄板レシピ\nlint-stagedは、「ステージング済みのファイルだけ」を対象に処理を高速実行することを目的としたツールである。\n## package.json（例）\nv10以降のlint-stagedは、タスクで変更されたファイルを自動でするため、配列の最後にを含める必要はない。\n## .husky/pre-commit（例）\nの設定で同じキーを重複定義した場合、後から定義したものが優先されるため、例えばのようなキーは一箇所にまとめるべきである。\n--\n# 4. Mermaid 構文検証の組み込み（レシピ）\nMermaidチャートを含むMarkdown/MDXファイルの品質をフックで担保するレシピを紹介する。\nまず、とを開発依存としてインストールする。\n次に、のような検証スクリプトを配置する。このスクリプトは、のような指定されたパスを対象とし、Markdownファイル内のコードフェンスを抽出する。抽出した内容は一時的なファイルに保存され、コマンドで構文が検証される。検証に失敗した場合、スクリプトはファイル名、開始行番号、エラー要旨を出力して終了コード1で終了する。環境変数が設定されていればそれが優先されるが、なければが自動的に解決される。\nこのスクリプトをlint-stagedと統合し、Markdownファイルがステージングされた際にのみ差分検証を実行する。\nまた、手動やCIで全ファイルをスキャンすることも可能である。のように引数で対象ディレクトリを指定したり、環境変数で実行バイナリを明示したりできる。\nCI/CD環境、特にLinux上でを実行する場合、内部で利用されるPuppeteer（Chromium）がサンドボックス関連の問題で失敗することがある。その場合、公式のDockerイメージ（）の利用を検討すると安定稼働が期待できる。\n--\n# 5. CI と Husky の棲み分け\nローカル環境とCI環境では、役割を明確に分けることが推奨される。ローカルではフックを用いて差分のみを高速に検証し、開発者へのフィードバックを迅速に行う。一方、CIではPull RequestやPushをトリガーとして全件チェックを行い、コードベース全体の品質を最終的に保証する。\n## GitHub Actions（最小例: Markdown Lint）\nこのCIワークフローにのような全件検証ステップを追加すれば、開発者がローカルでフックをスキップした場合でもエラーを確実に検出できる。\n--\n# 6. モノレポ（npm/pnpm/yarn workspaces）での運用\nモノレポ環境でHuskyを運用する場合、リポジトリのルートにディレクトリを配置し、ルートのにあるスクリプトでHuskyを有効化するのが基本である。lint-stagedのコマンドは、フラグなどを用いてワークスペース全体を対象とし、ルートにインストールされたツールを呼び出す。もしパッケージごとに局所的な規約が異なる場合は、のようなパスフィルターを用いて処理を分岐させる。pnpmを利用している場合、で初期化することも可能である。lint-stagedの実行は、ルートのバイナリを直接呼ぶなら、ルートのに定義したタスク経由ならのように記述する。\n--\n# 7. クロスプラットフォーム注意点\nチーム開発では、異なるOSの挙動を考慮する必要がある。内のフックスクリプトは、特定のシェルに依存しないPOSIX ベースで記述するのが安全である。Windows環境ではGit Bashがを提供するため、PowerShell専用の記法は避けるべきである。また、フックスクリプトにはコマンドで実行権限を付与し忘れないように注意が必要である。改行コードも問題を引き起こすことがあり、以下のファイルはLFで統一することが推奨される。CRLFは実行時エラーの原因となりうる。\n--\n# 8. 運用ポリシーとベストプラクティス\n快適な開発体験と品質担保を両立させるには、いくつかの運用ポリシーが有効である。まず、フックの処理は1～3秒程度で完了させ、重い処理はやCIに移行させることが「速いことは善」という原則に繋がる。次に、lint-stagedを用いて処理対象をステージング済みファイルのみに限定する「差分駆動」を徹底する。タスクの実行順序も重要で、コードフォーマッターなどによる自動整形（）を先に行い、その後に構文検証を実行するべきである。CI環境などで一時的にフックを無効化したい場合は、という環境変数を設定することでスキップできる。最後に、フックが失敗した際には、開発者が原因を即座に理解できるよう、明快なエラーメッセージと適切な終了コードを返すことが、優れた開発者体験に直結する。\n--\n# 9. トラブルシュート\nフックの運用で問題が発生した場合、原因と対処法を知っておくと解決が早い。というエラーは、がインストールされていない場合に発生するため、などを実行してスクリプトが正しく動作するか確認する。フックが全く動かない場合、ディレクトリ内のスクリプトに実行権限がない可能性が高いので、で権限を付与する。何も起きないように見えるときは、を確認し、他のツールによってhooksPathが上書きされていないか、またHusky管理下のディレクトリが存在するかをチェックする。Windowsでの実行失敗は、改行コードがCRLFになっているか、特定のシェルに依存した記述が原因であることが多い。内のファイルをLFに統一し、POSIX準拠のシェルで記述する。CIでのみ失敗する場合は、ローカルとCI環境でのNode.jsや依存パッケージのバージョン差異が考えられるため、やを用いて環境の再現性を担保する。lint-stagedが意図せず全ファイルを対象にしてしまう現象は、設定のフィルタが間違っているか、を誤用しているケースが考えられる。globパターンを見直し、フック内での不要なを削除する。\n--\n# 10. セキュリティ/メンテ注意\nGitフックは強力な仕組みである一方、セキュリティとメンテナンス性にも配慮が必要である。フック内でのように外部のスクリプトを直接実行するような実装は、セキュリティリスクを伴うため避けるべきである。自作の検証スクリプトはのような管理されたディレクトリに配置し、コードレビューの対象とすることが望ましい。また、APIトークンなどの機密情報をフック内で直接扱うべきではない。もし必要な場合は、環境変数経由で注入し、スクリプトのログに機密値が出力されないよう抑制するなどの対策を講じる。\n--\n# 付録A: サンプル \nここに示す依存バージョンはあくまで一例である。特にのように外部ツールに依存するものは、CI/CD環境での安定性を考慮し、最新版への追随を検討することが望ましい。\n--\n# 付録B:  完全例\n--\n# 付録C: CI で Mermaid も検証する例\n--\n# まとめ\nHuskyは、Gitフックをチームで共有可能な形で運用するための標準的な解決策である。フックとlint-stagedを組み合わせることで、処理対象をステージング済みの差分に絞り、開発体験を損なうことなく品質を担保できる。Mermaidの構文チェックのような分野特化の検証は、自作スクリプトをブロック化して組み込むことで、将来的な拡張も容易になる。ローカル環境では高速なフィードバックを重視し、CI環境では厳格な全体保証を行うという二段構えが、チーム開発における最適な戦略と言えるだろう。"
  },
  {
    "slug": "github",
    "layout": "../../layouts/BaseMarkdownLayout.astro",
    "title": "Git & GitHub 入門セットアップガイド（macOS）",
    "date": "2025-09-08",
    "description": "Git と GitHub の基本的なセットアップ手順を macOS 環境で解説",
    "author": "Mekann",
    "tags": [
      "Git",
      "GitHub"
    ],
    "content": "対象: macOS（Apple Silicon/Intel）で Git と GitHub CLI を使い始め、zsh + Znap + oh‑my‑zsh で快適に操作したい初学者〜中級者。\nGit及びGitHubの練習問題\n情報::https://github.com/Mekann2904/learning-gh\n--\n# 事前準備（Homebrew の確認）\nHomebrew が入っていない場合は先に導入します。\n未インストールの場合はhttps://brew.shを参照。\n--\n# Git のインストールと初期設定\n## 1) インストール & 動作確認\n## 2) ユーザー情報の設定（コミット署名者名・メール）\n## 3) 推奨の基本設定\nTips: お好みのエディタを設定（VS Code 例）\n--\n# GitHub CLI（gh）の導入と認証\n## 1) インストール & 確認\n## 2) GitHub へのログイン（SSH 推奨）\n## 3) 接続テスト（SSH）\n--\n# SSH/HTTPS \nSSH: パスワード不要・公開鍵認証で便利。複数リポジトリでも扱いやすい。\nHTTPS: 個別に Personal Access Token が必要になる場面がある。\n注意: リモート URL で SSH と HTTPS を混在させないこと。統一しましょう。\n--\n# zsh + Znap + oh‑my‑zsh の設定\n目的: 起動高速な Znap を使って oh‑my‑zsh とプラグインを効率的に読み込む。\n## 1) Znap 本体の導入\n## 2)  に追記\n※ ここでは ディレクトリを \\~/Repos/znap に統一します（混在を防ぐ）。\n## 3) 反映\n更新:  でクローン済みリポジトリを一括更新。\nOh-My-Zsh Git Cheat Sheet - Kapeli\n--\n# 最短クイックスタート（新規リポジトリ作成→GitHub へ push）\n--\n# チートシート\nOh‑My‑Zsh Git Cheat Sheet（英語）: Oh-My-Zsh Git Cheat Sheet - Kapeli\n--\n# 1) SSH 鍵運用の実務（GitHub での推奨）\n## 1.1 生成（ed25519 推奨）\n## 1.2 エージェント & macOS キーチェーン連携\n## 1.3 \\~/.ssh/config（単一/複数アカウント両対応）\n使い分け: リモート URL を （個人）/ （仕事） のように分ける。\n## 1.4 GitHub への鍵登録\n落とし穴:  は、鍵未登録・鍵ファイル権限・別アカウント参照が原因の 3 大パターン。\n--\n# 2) HTTPS を選ぶ場合（PAT）\nブラウザ/CI 互換が高い一方、Personal Access Token（PAT） が必要。\nmacOS は  で安全に保存。\n途中から SSH に移行するには：\n--\n# 3) GitHub CLI（gh）の実戦\nTips:  のように短縮化可能。"
  },
  {
    "slug": "google-fonts-optimizer",
    "layout": "../../layouts/BaseMarkdownLayout.astro",
    "title": "AstroでGoogle Fontsを最適化・インライン化する方法（astro-google-fonts-optimizer解説）",
    "date": "2025-07-17",
    "author": "AI Language Model (Gemini 2.5 Pro)",
    "tags": [
      "Astro",
      "Google Fonts",
      "Webパフォーマンス",
      "フォント最適化"
    ],
    "description": "Astroでastro-google-fonts-optimizerを使い、Google Fontsをビルド時にインライン化して高速化する方法・効果・注意点を解説します。",
    "content": "## AstroでGoogle Fontsを最適化する「astro-google-fonts-optimizer」の解説\nAstroサイトでGoogle Fontsを利用する際、インテグレーション「astro-google-fonts-optimizer」を導入することで、パフォーマンスを向上させることができる。このツールは、ビルド時にフォント用のCSSをHTMLに直接インライン化し、ページの表示速度を改善する。\n----\n## なぜGoogle Fontsの最適化が必要か？\n通常、Google Fontsをタグで読み込むと、ブラウザは以下の順で処理を行う。\n1.  HTMLのレンダリングを一時停止する。\n2.  GoogleのサーバーへCSSファイルをリクエストし、ダウンロードする。\n3.  CSSファイルの内容を解析し、その中に記述されたフォントファイル（など）をダウンロードする。\nこの「CSS取得」のステップはレンダリングブロックとなり、後続のフォントファイルのダウンロードも遅延させるため、ページの初回表示（FCP: First Contentful Paint）が悪化する一因となる。\nは、この最初のCSS取得リクエストを不要にすることで、このボトルネックを解消する。\n----\n## astro-google-fonts-optimizerの導入手順\n### 1\\. パッケージのインストール\nプロジェクトにパッケージを追加する。\n### 2\\. コンポーネントの利用\nレイアウトファイルやコンポーネントのタグ内で、コンポーネントをインポートして使用する。\n例: \n  * プロパティには、Google Fontsで生成されるCSSのURLをそのまま指定する。\n  * 複数のフォントファミリーやウェイトは、で繋げて1つのURLにまとめるのが標準的な方法である。\n----\n## ビルド時に何が起こるか？\nを実行すると、は指定されたURLからCSSファイルの内容を取得し、HTMLファイルの内に直接タグとして埋め込む。\nビルド後のHTML（抜粋）\nこれにより、ブラウザは外部CSSをダウンロードすることなく、すぐにフォントファイルの取得を開始できる。\n----\n## 主な効果とベストプラクティス\n  * 初回表示の高速化: レンダリングをブロックする外部CSSリクエストがなくなるため、ページの読み込みが速くなる。\n  * レイアウトシフトの抑制: がCSSに含まれるため、フォント適用時のちらつき（FOUT）やレイアウトのずれ（CLS）を軽減する効果が期待できる。\n  * データ量の最適化: で指定するフォントは、実際にサイトで使用するファミリーとウェイト（太さ）のみに限定すること。不要なフォントを読み込まないことがパフォーマンスの鍵となる。\n----\n## 注意点\n  * フォントファイル自体はGoogleから配信: このツールはCSSをインライン化するだけで、フォントファイル（など）自体をセルフホストするわけではない。そのため、ユーザーのブラウザは引き続きGoogleのサーバー（）へアクセスする。\n  * ライセンスの確認: Google Fontsの利用規約および各フォントのライセンスは、プロジェクトの要件と合致しているか各自で確認すること。\n  * URLの更新: 使用するフォントを変更・追加した場合は、コンポーネントのプロパティを忘れずに更新する必要がある。\n----\n## 参考リンク\n  * GitHub: sebholstein/astro-google-fonts-optimizer\n  * Google Fonts: fonts.google.com"
  },
  {
    "slug": "image-embedding-guide",
    "layout": "../../layouts/BaseMarkdownLayout.astro",
    "title": "Astro + MDXで画像を最適化して埋め込む方法",
    "date": "2025-07-17",
    "author": "AI Language Model (Gemini 2.5 Pro)",
    "description": "AstroのMDX記事で画像を最適化しつつ埋め込むベストプラクティス",
    "tags": [
      "Astro",
      "画像最適化",
      "MDX",
      "Webパフォーマンス"
    ],
    "content": "Astroブログ全体にプリフェッチを有効化する方法\nAstroのMDX記事で画像を最適化しつつ埋め込むには、以下の手順を踏む。\n# 1. frontmatterはYAMLのみ\nMDXファイルの先頭はYAML形式で記述し、importやJS式は書かない。\n# 2. 画像のimport\nfrontmatterの直後で、astro:assetsのImageコンポーネントと画像ファイルをimportする。\n# 3. 画像の埋め込み\n本文中でimportした画像変数を`<img src={...} />src/assets/public/`配下は最適化されない）\n--\n# 参考\nAstro公式: 画像最適化ガイド\nAstro公式: MDXガイド"
  },
  {
    "slug": "inline-css-astro",
    "layout": "../../layouts/BaseMarkdownLayout.astro",
    "title": "AstroでCSSをインライン化する方法と注意点",
    "date": "2025-07-17",
    "author": "AI Language Model (Gemini 2.5 Pro)",
    "tags": [
      "Astro",
      "CSS最適化",
      "Webパフォーマンス"
    ],
    "description": "Astroで@playform/inlineを使い、CSSをインライン化してパフォーマンスを向上させる方法と、Crittersの設定・注意点・トラブル事例を詳しく解説します。",
    "content": "Astroにビルドファイル圧縮を導入する\nAstroでは、CSSをインライン化することで初回表示のパフォーマンスを大きく向上させることができます。この記事では、@playform/inlineパッケージとCrittersを使った最新のCSSインライン化手法、その設定例、実際に発生したトラブルと対策まで詳しく解説します。\n----\n## なぜCSSをインライン化するのか？\nWebサイトでは、CSSが適用される前の「スタイルなしページ（FOUC）」が一瞬でも表示されると、ユーザー体験が大きく損なわれます。CSSをインライン化することで、最初に必要なスタイルだけを即座に適用し、見た目の崩れや遅延を防ぐことができます。\nただし、全ページで使わないCSSまで一括で読み込むと、無駄な通信が発生します。インライン化は「本当に必要なCSSだけを最初に読み込む」ための最適化手法です。\n----\n## @playform/inlineの導入手順\n1. パッケージのインストール\n2. astro.config.mjsへの設定追加\n の設定で、Webフォントのインライン化のみを無効化できます。\nこれにより、CSSはインライン化されますが、Webフォントは通常通り外部リソースとして読み込まれます。\n----\n## Crittersとは？\n@playform/inlineは内部的にCrittersというCSSインライン化ツールを利用しています。Crittersの設定はそのまま渡すことができ、細かい挙動を制御可能です。\n例: \n----\n## 注意点・トラブル事例\n実際に本番環境で適用した際、**Webフォントがロードされない**という問題が発生することがあります。これはGoogle Fonts最適化系の他プラグイン（例: GoogleFontsOptimizer）との相性や、Crittersの仕様によるものかもしれません。\nフォントが表示されない場合は、でインライン化を無効化しても解決しないことがあります。\nその場合は、他のフォント最適化プラグインとの併用を見直すか、Crittersの使用を一時的に停止するのが無難です。\n----\n## ベストプラクティス\n**まずは本番環境で十分にテスト**しましょう。\nフォント最適化系プラグインとの併用時は、挙動に注意。\n通信量やパフォーマンスの変化は、LighthouseやWebPageTestなどで計測して確認しましょう。\n----\n## 参考リンク\n@playform/inline GitHub\nCritters公式\nAstro公式ドキュメント\n--\nAstroでのCSSインライン化は、パフォーマンス改善に非常に有効な手法です。Webフォントや他プラグインとの相性に注意しつつ、最適な設定を見つけてみてください。 \n----\n## 外部CSS運用への回帰と安定性について\n実際にTailwind CSSやAstroのView Transitions、プリフェッチ機能を併用した場合、CSSインライン化（@playform/inline + Critters）によって「幅が揃う」「色が遅れて反映される」などのラグやレイアウトの乱れが発生することがあります。\nこれは、インライン化されるCSSが「初回表示に必要な分」だけになるため、ページ遷移や動的なUI変化時に必要なCSSがまだ読み込まれておらず、一瞬デフォルトの見た目で表示されてしまうためです。\n特にTailwindのようなユーティリティCSSや、クライアントサイド遷移が多いサイトではこの現象が顕著です。\n### 解決策・ベストプラクティス\n**安定性を最優先する場合は、CSSインライン化をやめて外部CSS運用に戻すのが最も確実です。**\n外部CSS運用に戻すことで、ページ遷移時や動的UIの変化でも常に全てのスタイルが適用され、ラグや乱れが解消されます。\nCrittersの設定をいろいろ調整しても安定しない場合は、迷わず外部CSS運用に切り替えましょう。\n### 判断基準\nサイトのパフォーマンス計測（Lighthouse等）で「レイアウトシフト」や「スタイル適用の遅延」が目立つ場合\n実際のユーザー体験で「幅が揃う」「色が遅れる」などの違和感が残る場合\nTailwindやView Transitions、プリフェッチを積極的に使っている場合\nこのような場合は、**外部CSS運用が最も安定し、ユーザー体験も向上します。**\n--\nAstroでのCSS最適化は、サイトの規模や構成、使っている技術スタックによって最適解が変わります。インライン化と外部CSS運用の両方を試し、実際の挙動やパフォーマンスを比較しながら、最適な方法を選択してください。"
  },
  {
    "slug": "llm-suggester",
    "layout": "../../layouts/BaseMarkdownLayout.astro",
    "title": "プロンプト入力を効率化するコマンド提案ツールの公開",
    "date": "2025-07-22",
    "description": "Google Gemini及びChatGPTのウェブサイトにおいて、定型的なプロンプト入力を効率化するUserScript「Command Suggester」を公開した。本稿ではその概要と利用法について報告する。",
    "author": "AI Language Model (Gemini 2.5 Pro)",
    "tags": [
      "UserScript",
      "Google Gemini",
      "ChatGPT",
      "Violentmonkey"
    ],
    "content": "# 1. はじめに\n近年、Google GeminiやChatGPTに代表される生成AIの利用が拡大する一方、反復的なプロンプト入力が作業効率を低下させるという課題が指摘されている。例えば、文章要約やコードレビューといった定型業務では、毎回類似した指示を入力する必要がある。\nこの課題を解決するため、「Google Gemini Command Suggester」および「ChatGPT Command Suggester」と称するUserScriptが開発された。本稿では、これらのツールが提供する機能、動作原理、そして導入方法について詳述する。本ツールは、頻用するプロンプトをコマンドとして登録・呼び出し可能にすることで、AIとの対話における生産性向上を目的とする。\n# 2. 主な機能\n本ツールの中心的な機能は、プロンプト入力の補助である。\n利用者がAIのテキスト入力欄に特定のトリガー文字（例：「:」）を入力すると、事前登録されたコマンドの候補リストがポップアップ形式で表示される。利用者はキーボード操作のみでコマンドを選択でき、Enterキーで確定すると、対応するプロンプトが入力欄に自動で挿入される仕組みだ。\nこれにより、タイピング量が削減されるだけでなく、プロンプトの品質維持や入力ミスの防止といった効果も期待できる。コマンドは利用者がJavaScriptファイルを直接編集することで、自由に追加・変更が可能であり、各々の用途に最適化されたコマンドセットを構築できる。\n具体的な利用例：\n文章要約: 「」というコマンドに対し、「以下の文章を300字程度で要約せよ。」というプロンプトを割り当てる。\nコードレビュー: 「」に対し、「以下のコードについて、リファクタリング案や潜在的な不具合を指摘せよ。」という定型文を割り当てる。\n# 3. 動作原理\n本ツールは、ウェブページの動作をカスタマイズする「UserScript」として実装されている。動作には、ViolentmonkeyやTampermonkeyといったUserScript管理用のブラウザ拡張機能（UserScriptマネージャー）が必須となる。\n技術的根幹はJavaScriptであり、UserScriptマネージャーを介して対象のウェブページ（Google GeminiまたはChatGPT）で以下の処理を実行する。\n1.  イベント監視 (Event Listener): ページの入力欄（テキストエリア）におけるキーボード入力イベントを常時監視する。\n2.  トリガー検知: トリガー文字の入力を検知すると、定義済みのコマンドリストに基づき、UI（ポップアップリスト）を動的に生成・表示する。\n3.  DOM操作: 利用者がリストからコマンドを選択すると、JavaScriptがウェブページのDOM (Document Object Model) を操作し、選択されたテキストを入力欄に反映させる。\nこの一連の処理により、既存のウェブサイトの機能を変更することなく、新たな機能を付加的に実現している。\n# 4. 導入手順\n本ツールの導入は、以下の手順で行う。\n1.  UserScriptマネージャーの導入:\n    利用中のウェブブラウザ（Chrome, Firefox等）に、ViolentmonkeyまたはTampermonkeyの拡張機能を事前にインストールしておく。\n2.  スクリプトのインストール:\n    後述の「6. 情報源」に記載のGitHubリポジトリにアクセスする。リポジトリ内に存在する  拡張子のファイル（例: ）をクリックする。\n3.  インストールの承認:\n    上記操作により、UserScriptマネージャーのインストール確認画面が自動的に起動する。スクリプトの名称や実行対象サイトなどの情報を確認の上、「インストール」を実行する。\n以上の手順でセットアップは完了し、即座にコマンド提案機能が利用可能となる。\n# 5. まとめ\n「Google Gemini Command Suggester」および「ChatGPT Command Suggester」は、生成AIの利用における定型作業を自動化し、利用者の生産性を向上させる実用的なツールである。本ツールは単なる入力補助に留まらず、思考を中断することなく対話を継続するための支援を提供し、より高度な問題解決や創造的タスクへの集中を可能にする。\nオープンソースであるため透明性が高く、利用者が自身のニーズに応じて機能を拡張できる点も利点である。将来的には、チーム内での優れたプロンプトの共有基盤としての活用も期待される。\n# 6. 情報源\nGoogle Gemini Command Suggester: https://github.com/Mekann2904/Google-Gemini-Command-Suggester\nChatGPT Command Suggester: https://github.com/Mekann2904/ChatGPT-Command-Suggester"
  },
  {
    "slug": "mac-smartmontools",
    "layout": "../../layouts/BaseMarkdownLayout.astro",
    "title": "macOSでsmartmontoolsを使ってディスク情報を確認する",
    "date": "2025-07-15",
    "description": "macOSでsmartmontoolsを使ってディスク情報を確認する方法を解説する。",
    "author": "AI Language Model (Gemini 2.5 Pro)",
    "tags": [
      "macOS",
      "smartmontools",
      "ディスク情報",
      "温度情報"
    ],
    "content": "この記事では、macOS環境でというツールをHomebrewを使ってインストールし、接続されているディスクの情報を確認する手順を解説する。特に、外部ディスクの温度情報を取得する例を見ていく。\n## 1. smartmontoolsのインストール\nは、S.M.A.R.T. (Self-Monitoring, Analysis and Reporting Technology) データを通じて、ハードディスクやSSDの健康状態を監視するためのユーティリティだ。macOSでは、Homebrewパッケージマネージャーを使って簡単にインストールできる。\nまず、以下のコマンドを実行してをインストールする。\n*実行結果の解説:**\n上記の出力から、Homebrewが自動更新された後、のバージョン7.5が正常にインストールされたことがわかる。インストールされたファイルはに配置され、インストール後に自動的にクリーンアップが実行されている。\n## 2. 接続されているディスクの識別\nを使ってディスク情報を取得する前に、どのディスクを対象にするか識別しなければならない。コマンドを使うと、システムに接続されているすべてのディスクとそのパーティション情報を一覧表示できる。\n*実行結果の解説:**\nこの出力から、以下のディスクが確認できる。\n: 251.0 GBの内部物理ディスク。macOSのシステムがインストールされている。\n: 2.0 TBの外部物理ディスク。このディスクはAPFSコンテナを含んでいる。\n: から合成されたAPFSコンテナで、「MSI M482 - Data」や「MSI M482」といったボリュームが含まれている。\n今回は、この外部ディスクの情報を取得することにする。\n## 3. smartctlで温度情報を取得\nに含まれるコマンドを使って、特定のディスクのS.M.A.R.T.情報を取得できる。ディスクの温度情報を確認するには、オプションで全てのS.M.A.R.T.情報を表示し、で温度に関する行をフィルタリングするのが便利だ。\nはディスクに直接アクセスするため、コマンドで管理者権限が必要になる。\n*実行結果の解説:**\n上記の出力から、外部ディスクの現在の温度は**37℃**であることがわかる。また、温度センサー1の値も同じく37℃を示している。\n## まとめ\nこの手順により、Homebrewを使ってをmacOSにインストールし、でディスクを識別した後、コマンドで外部ディスクの温度情報を正常に取得できた。"
  },
  {
    "slug": "obsidian-textlint",
    "layout": "../../layouts/BaseMarkdownLayout.astro",
    "title": "高度な日本語校正をObsidianで実現する \n「Textlint Highlighter Plugin」をリリースしました",
    "date": "2025-07-09",
    "description": "Obsidianで動作するtextlintプラグインです。リアルタイムで文章を校正し、問題箇所をエディタ上でハイライト表示します。",
    "author": "AI Language Model (Gemini 2.5 Pro)",
    "tags": [
      "Obsidian",
      "textlint",
      "プラグイン",
      "日本語校正"
    ],
    "content": "この記事はAIによって自動生成されました。\n# はじめに\nObsidianで日本語の文章を書くすべてのユーザーへ。  \n「表記ゆれをなくしたい」「技術記事の品質を上げたい」  \n「チームのドキュメントルールを統一したい」  \nそんな悩みを解決するプラグインが **Obsidian Textlint Highlighter Plugin** です。\nこのプラグインは、Node.js製の強力なテキスト校正ツール \\ をObsidianに統合します。これにより、あなたの文章作成は次のレベルへと引き上げられます。本記事では、その強力な機能と具体的な使い方を解説します。\n  \n  \n--\n# 1\\. Textlint Highlighter Pluginとは\nこのプラグインは、入力された日本語のテキストを \\ を使ってリアルタイムに解析し、問題点をエディタ上にハイライト表示するものです。これにより、文章の推敲にかかる時間を削減し、より執筆に集中できる環境を構築します。\n## textlintとは\ntextlint は、プラグイン形式で校正ルールを追加できる、非常に柔軟で強力なテキスト校正エンジンです。例えば、以下のようなチェックを自動化できます。\n**技術文書向けの表記統一** (例: \\)\n**敬体（ですます調）と常体（である調）の混在チェック** (例: \\)\n**表記ゆれのチェック** (例: \\ を利用し、\\ / \\ などを統一)\n**漢字の閉じ開き** (例: \\)\nこれらのルールを組み合わせることで、自分だけ、あるいはチームだけの文章執筆規約を構築できます。\n--\n# 2\\. 主な機能詳解\n## 2.1. リアルタイム・ハイライト機能\nこのプラグインを有効にすると、エディタ上で文章を記述するそばから自動で校正が実行されます。\\ が検出した問題点は即座にハイライトされ、マウスカーソルを合わせると「なぜこれが問題なのか」という理由が表示されます。\nこれにより、修正すべき箇所とその理由が一目瞭然となり、文章を書きながらスムーズに推敲作業を進めることができます。\n## 2.2. 柔軟なルールカスタマイズ\n本プラグインの真価は、その圧倒的なカスタマイズ性にあります。\n## prh.ymlによる表記ゆれチェック\n\\ というYAMLファイルを使うことで、独自の表記ゆれ辞書を簡単に作成できます。\n例: \\\nこのファイルをプラグイン設定で読み込ませるだけで、「サーバ」と書かれた箇所を自動で検出し、「サーバー」への修正を促してくれます。\n## Textlintルールの導入\nnpmで配布されている豊富なtextlintルールを導入できます。ただし、別途Node.js環境が必要になる場合があります。  \n例えば、\\ のようなプリセットを導入すれば、技術文書執筆における一般的な規約をまとめて適用できます。\n## 2.3. ルール・プリセット管理画面\n「たくさんのルールを導入したのはいいけど、今どれが有効になっているか分からない…」  \nそんな悩みを解決するのが、設定画面にある **ルール・プリセット一覧表示機能** です。\nプラグイン設定画面を開くと、現在読み込まれている全てのルールが一覧で表示されます。\nルールのON/OFF: 各ルールの横にあるチェックボックスを切り替えるだけで、一時的にルールを無効化できます。\n設定の確認: どのルールファイルから読み込まれているかが明記されており、管理が容易です。\nこれにより、プロジェクトや文書の種類に応じて、適用するルールセットを柔軟に切り替えるといった高度な使い方が可能になります。\n## 2.4. パフォーマンスへの配慮\nリアルタイムで校正処理が走ると、特に長文のファイルではパフォーマンスが心配になります。  \nこのプラグインは、その点も考慮して設計されています。\nキャッシュ機構: 一度校正した結果をキャッシュし、変更があった部分だけを再計算することで、エディタの応答性を損なわないように工夫されています。\nこれにより、数万文字を超えるような長大なドキュメントでも、ストレスなく執筆を続けることができます。\nobsidian-textlint-highlighter-plugin  \nかなりサクサクで、30万字のメモでも動作を確認。 pic.twitter.com/qlr8s5kJzU\n— Mekann (@Mekann2904) July 8, 2025\n  \n--\n# 3\\. インストールと設定\n## インストール\n1. **\\[推奨\\] BRATを利用する方法**\n\t1. コミュニティプラグイン \\ をインストールします。\n\t2. BRATの設定で \\ を選択します。本プラグインのGitHubリポジトリURL (\\obsidian-textlint-highlighter-plugin.zip\\prh.yml\\prh.yml file path\\textlint\\prh.yml\\` や textlintルールによる無限のカスタマイズ性**\n**分かりやすいルール管理UI**\n**長文でも安心のパフォーマンス**\nこれらの特徴により、ブロガー、技術者、編集者、学生など、質の高い日本語文章を求めるすべての人にとって、不可欠なプラグインとなるでしょう。\nぜひこのプラグインを導入して、より快適で創造的な執筆活動をお楽しみください。\n--\n# ライセンス\nMIT License\n  \n高度な日本語校正をObsidianで実現する「Textlint Highlighter Plugin」をリリースしました｜Mekann"
  },
  {
    "slug": "prefetch-enabled",
    "layout": "../../layouts/BaseMarkdownLayout.astro",
    "title": "Astroブログ全体にプリフェッチを有効化する方法",
    "date": "2025-07-17",
    "author": "AI Language Model (Gemini 2.5 Pro)",
    "tags": [
      "Astro",
      "プリフェッチ",
      "Webパフォーマンス"
    ],
    "description": "Astro v5以降では、サイト全体のリンクに対してプリフェッチ（事前読み込み）を簡単に有効化できます。この記事では、実際にブログ全体でプリフェッチを有効化した手順と、その効果・注意点についてまとめます。",
    "content": "AstroでCSSをインライン化する方法と注意点\nAstro v4.5から導入され、v5でさらに強化されたクライアントサイドのルーティングとプリフェッチ機能は、Webサイトのパフォーマンスを劇的に向上させる。この記事では、Astroのプリフェッチ機能の仕組みから、サイト全体で有効化する具体的な設定方法、詳細なオプション、そして注意点までを深く掘り下げて解説する。\n----\n## プリフェッチとは？\nプリフェッチ（Prefetching）とは、ユーザーが次に行うであろうナビゲーションを予測し、遷移先のページリソースを事前に読み込んでおく技術である。これにより、ユーザーがリンクをクリックした際には、すでにデータがブラウザにキャッシュされているため、ネットワークの待ち時間なしに瞬時にページを表示できる。\nAstroのプリフェッチは、単にHTMLを読み込むだけではない。遷移先のページのHTMLと、そのページのレンダリングに必要なCSSやJavaScriptモジュールも同時に取得するため、非常に高速なページ遷移が実現する。この機能はAstroのView Transitionsと連携することで、滑らかなアニメーションを伴うシームレスなユーザー体験を提供する。\n----\n## プリフェッチの設定方法 \nプリフェッチの挙動は、 ファイルと、個別の  タグに付与する  属性で細かく制御できる。\n### サイト全体での設定\n に  オブジェクトを追加することで、サイト全体のデフォルトの挙動を定義できる。\n は、ビューポート（画面表示領域）に入った全てのリンクを自動的にプリフェッチの対象にするための強力なオプションだ。ブログやドキュメントサイトのように、ページ間の回遊性が高いサイトに最適である。\n は、 が  の場合や、 が指定されたリンクが、どのタイミングでプリフェッチされるかを決定する。\n### プリフェッチ戦略（Prefetch Strategies）\nAstroでは、プリフェッチを実行するタイミングを4つの戦略から選択できる。\n  *  (デフォルト): リンクにマウスカーソルが乗った時、またはフォーカスが当たった時にプリフェッチする。最も一般的な戦略。\n  * : ユーザーがリンクをタップまたはクリックする直前にプリフェッチする。モバイルデバイスでの応答性を高めるのに有効。\n  * : リンクがビューポートに入った瞬間にプリフェッチする。ユーザーが目にする可能性が高いリンクを積極的に読み込む。\n  * : ページの初期読み込みが完了した直後に、ページ上の全ての対象リンクをプリフェッチする。最も重要なリンク（CTAボタンなど）に使うと効果的。\n### 個別リンクでの設定\nサイト全体の設定を上書きしたい場合や、特定のリンクだけ挙動を変えたい場合は、 タグに  属性を直接記述する。\n を指定すれば、そのリンクはプリフェッチの対象外となる。これは、外部リンクやサイズの大きいファイルへのリンクに設定すると良いだろう。\n----\n## 期待できる効果 \n  * 圧倒的なページ遷移速度: ユーザーがリンクをクリックした時点でリソースがキャッシュされているため、体感速度が劇的に向上する。特にブログ記事間の移動などが極めてスムーズになる。\n  * ユーザー体験（UX）の向上: 待ち時間のない軽快な操作感は、ユーザー満足度を直接的に高める。\n  * コアウェブバイタルの改善: ページ遷移の応答性が向上するため、特に  のスコア改善に寄与する可能性がある。\nプリフェッチの動作は、ブラウザの開発者ツールの「ネットワーク」タブを開き、リンクにホバーしたりスクロールしたりすることで、実際のリクエストが発生していることを確認できる。\n----\n## 注意点とベストプラクティス \nプリフェッチは強力な機能だが、無計画な導入は逆効果になる可能性もある。\n  * データ通信量の増加: 全てのリンクを無差別にプリフェッチすると、ユーザーが実際には訪問しないページのデータまでダウンロードしてしまい、特にモバイル環境ではデータ通信量を無駄に消費させてしまう。 を使う際は、サイトの特性をよく考慮する必要がある。\n  * サーバー負荷: 静的生成されたサイト（SSG）では大きな問題になりにくいが、サーバーサイドレンダリング（SSR）で動的なリクエストが多いサイトの場合、プリフェッチによるリクエスト増加がサーバー負荷を高める可能性がある。\n  * 戦略的な使い分け:\n      * ブログ記事一覧: ユーザーが次に読みそうな記事リンクには  が効果的だ。\n      * グローバルナビゲーション: 常に表示されているヘッダーやフッターのリンクには  や  が適している。\n      * 重要なCTA: 「購入」や「登録」など、ユーザーに必ず踏んでほしいリンクには  を使い、最速で表示できるように準備しておくのが良いだろう。\n      * 外部リンク・ファイル: プリフェッチが不要なリンクには、必ず  を設定する。\n## 参考リンク\n  * Astro公式プリフェッチガイド（日本語）\n----\nAstroのプリフェッチ機能は、設定が非常に簡単でありながら、Webサイトのパフォーマンスとユーザー体験を飛躍的に向上させるポテンシャルを秘めている。サイトのコンテンツやユーザーの行動を考慮し、最適な戦略を選択することが、その効果を最大限に引き出す鍵となるだろう。"
  },
  {
    "slug": "re-gh",
    "layout": "../../layouts/BaseMarkdownLayout.astro",
    "title": "Git及びGitHubの練習問題",
    "date": "2025-09-08",
    "description": "Git及びGitHubの練習問題",
    "author": "Mekann",
    "tags": [
      "Git",
      "GitHub"
    ],
    "content": "Git hooksの実践ガイド\n# この記事について\nこの記事は、GitおよびGitHubの基本的な操作に慣れるための練習問題と、その手順をまとめたガイドである。\n コマンド（GitHub CLI）を中心に、実際の開発フローをコマンドラインで体験することを目的とする。\nリポジトリの作成、ブランチの操作、変更のコミットとプッシュ、そしてプルリクエストの管理といった内容を学習する。\nコマンドの実行例に続いて、最後に理解度を確認するための練習問題がある。\n# レポジトリを作成する\nコマンドは、GitHub上に新しいリポジトリを作成する。\nというコマンドは、という名前で公開（）リポジトリを作成し、フラグによってファイルを自動生成する。さらに（）フラグで、作成したリポジトリをローカルにクローンする。\nコマンドは、現在いるローカルリポジトリに対応するGitHubリポジトリをブラウザで開く。\n--\nまた、既存のローカルディレクトリをGitHubリポジトリとして公開することもできる。\nまずとでディレクトリを作成して移動し、でGitリポジトリとして初期化する。最後にコマンドを実行すると、現在のディレクトリをソースとしてGitHubリポジトリが作成され、リモートURLも自動で設定される。\n# ブランチを作成し、作業ブランチに切り替える\nは  のエイリアス（別名）の可能性があり、これは  という名前の新しいブランチを作成し、そのブランチにすぐに切り替えるコマンドである。\nは  のエイリアスの可能性があり、ローカルに存在するブランチの一覧を表示するコマンドである。\n# ブランチに変更を加え、プッシュする\nコマンドでというファイルを作成してという文字列を書き込み、（のエイリアスと思われる）ですべての変更をステージングする。次に（のエイリアスと思われる）でコミットメッセージを付けて変更を記録する。（のエイリアスと思われる）でプッシュを試みるが、初回はアップストリームブランチがないため失敗する。そのため、を実行し、リモートにブランチをプッシュすると同時にアップストリームを設定する。これにより、次回以降はだけでプッシュが可能になる。\n# プルリクエストを作成する\nコマンドは、現在のブランチからプルリクエストを作成するための対話的なプロンプトを開始する。タイトルや本文などを質問され、最後にするとGitHub上にプルリクエストが作成される。\n# プルリクエストを確認する\nコマンドでオープンなプルリクエストの一覧を表示し、で指定したプルリクエストの詳細を確認できる。\n# プルリクエストをレビューする\nコマンドで指定したプルリクエストにコメントを追加する。実行するとデフォルトのエディタが起動し、コメントを記述できる。\n# プルリクエストをマージする\nコマンドで指定したプルリクエストをマージする。この際、マージ方法（Merge, Squash, Rebase）を選択するプロンプトが表示されることもある。\n# 練習問題\n1. 新規に公開レポジトリ  を作成し、 を自動生成してブラウザで開いてください。\n2. 既存ディレクトリからレポジトリを初期化し、同名の GitHub レポジトリを作成・関連付けてください。\n3. 作業用ブランチ  を作成して切り替えてください。\n4.  に1行追記し、コミットメッセージ「docs: update readme」でコミットしてください。\n5. アップストリームを設定してブランチをリモートへプッシュしてください。\n6. CLI を使ってプルリクエストを作成し、タイトルを「Update README」、本文を任意で作成してください。\n7. 現在オープン中のプルリクエスト一覧を表示し、該当 PR の詳細を確認してください。\n8. PR にコメントを 1 件追加してください。\n9. PR をマージし、ブランチをリモートから削除してください。\n10. マージ後、ローカルの  を最新に更新し、不要になったローカルブランチを削除してください。"
  },
  {
    "slug": "vault-organizer",
    "layout": "../../layouts/BaseMarkdownLayout.astro",
    "title": "Obsidianプラグイン「vault-organizer」リリースしました",
    "date": "2025-02-23",
    "description": "Obsidianプラグイン「vault-organizer」のリリースについて",
    "author": "AI Language Model (Gemini 2.5 Pro)",
    "tags": [
      "Obsidian",
      "プラグイン",
      "vault-organizer"
    ],
    "content": "# Obsidianプラグイン「vault-organizer」リリースしました\n日々のノート管理や情報整理をさらに効率化するために、新たなプラグイン「vault-organizer」をリリースしました。今回のリリースでは、 Obsidian Vaultのルートファイル を自動的に整理し、作業環境のクリーンアップと効率アップを実現することを目指しています。\n  \n--\n# はじめに\nObsidianは柔軟性とカスタマイズ性の高さが魅力ですが、 Vaultのルート に大量のファイルが散在すると、情報の検索や管理が煩雑になることもあります。そこで、今回リリースした「vault-organizer」は、ファイルの種類やルールに基づいて自動で整理・移動を行うことで、ユーザーの作業効率を向上させるプラグインです。\nhttps://github.com/Mekann2904/obsidian-vault-organizer-plugin\n--\n# 「vault-organizer」の概要\n「vault-organizer」は、以下のような特徴を持っています。\n自動分類機能  \n\tファイル拡張子や設定したルールに応じて、 Vaultルートのファイル を指定のフォルダへ自動移動。例えば、Markdownファイルは特定のディレクトリに、画像ファイルは画像用のフォルダに振り分けることが可能です。\nUndo（元に戻す）機能  \n\t誤ってファイルが移動された場合でも、 移動前の状態に戻す Undo機能を搭載。安全に整理作業を実行できます。\n直感的な設定画面  \n\tプラグイン専用の設定タブから、各ファイルタイプに対する移動先フォルダの設定が簡単に行えます。フォルダ選択のための サジェスト機能 も用意されており、手軽に設定が可能です。\n実行はリボンまたはコマンドパレットから行えます。  \n--\n# 主な機能\n## 手動によるファイル移動\n対象ファイルのスキャン  \n\tVaultのルートフォルダにあるファイルを自動的に検出し、拡張子に応じた移動先へ分類します。\n安全なリネーム  \n\t同名ファイルが存在する場合でも、連番を付与することで名前の衝突を防ぎ、確実に移動を実行します。\n## Undo機能\n移動履歴の保持  \n\t実行したファイル移動の履歴を保存し、必要に応じて一括で元に戻すことができます。\n--\n# インストール方法\n1. プラグインのダウンロード  \n\tGitHubなどで公開している「vault-organizer」のコードを入手し、Obsidianのプラグインフォルダに配置してください。\n2. サードパーティプラグインの有効化  \n\tObsidianの設定画面から「Community Plugins」を選択し、サードパーティ製プラグインの利用を有効にしてください。\n3. プラグインの起動  \n\tプラグイン一覧から「vault-organizer」を探し、\\[Enable\\]ボタンをクリックして有効化してください。\n--\n# 使用例\n例えば、以下のようなシナリオで活用できます。\nノート整理  \n\tVaultのルートに散らばるMarkdownファイルを、指定した「Notes」フォルダに自動で整理。\n画像管理  \n\t画像ファイル（.png,.jpegなど）を、事前に設定した「Images」フォルダへ一括移動。\nファイル整理の失敗も安心  \n\t誤って移動してしまった場合でも、Undo機能で一括復元が可能なため、安心して操作できます。\n--\n# 今後の展望\n今回のリリースは第一弾として、基本的なファイル整理機能を中心に実装しました。今後は、ユーザーからのフィードバックがあれば、さらに高度な分類ルールの追加や、カスタムスクリプトとの連携機能など、機能拡張を予定しています。Obsidianユーザーの皆様の作業環境が、よりスマートに、そして快適になることを目指して開発を進めてまいります。\n--\n# まとめ\n「vault-organizer」は、Obsidianを日常的に利用されている方々にとって、Vault内のファイル整理を大幅に効率化する新たなツールです。自動分類、Undo機能、直感的な設定画面など、多くの機能を備えている本プラグインをぜひお試しください。皆様からのフィードバックもお待ちしております！\n今後とも、より良いプラグインの提供に努めてまいりますので、どうぞご期待ください。\n--\n以上、Obsidianプラグイン「vault-organizer」リリースのお知らせでした。  \n皆様の快適なノートライフをサポートできることを心より願っています。"
  },
  {
    "slug": "violentmonkey",
    "layout": "../../layouts/BaseMarkdownLayout.astro",
    "title": "Violentmonkeyとは",
    "date": "2025-07-22",
    "description": "Webページを自分好みに改造できる「UserScript」。その管理・実行を担うモダンで高機能なブラウザ拡張機能「Violentmonkey」の紹介",
    "author": "AI Language Model (Gemini 2.5 Pro)",
    "tags": [
      "UserScript",
      "Violentmonkey",
      "ブラウザ拡張機能",
      "Tampermonkey"
    ],
    "content": "X Bookmarks Exporter を公開しました。\nプロンプト入力を効率化するコマンド提案ツールの公開\n# 概要\n*Violentmonkey**は、Webページを自分好みにカスタマイズするための「UserScript」を管理・実行するためのブラウザ拡張機能である。\n普段利用しているWebサイトの見た目を変更したり、新しい機能を追加したり、面倒な操作を自動化したりと、Webブラウジングの体験を根底から向上させることができる。\nオープンソースで開発されており、同様の拡張機能であるTampermonkeyに並ぶ、パワフルな選択肢として広く利用されている。\n--\n# UserScriptで何ができるのか\nViolentmonkeyにUserScriptをインストールすると、例えば以下のようなことが可能になる。\n**サイトのデザイン変更**: 特定のサイトをダークモードで表示したり、不要な要素（広告など）を非表示にする。\n**機能の追加**: YouTubeの動画ページにダウンロードボタンを追加したり、X（旧Twitter）の画像をワンクリックで保存できるようにする。\n**操作の自動化**: フォームへの定型文入力を自動化したり、特定のサイトの巡回をスクリプトに任せる。\n**外部サービスとの連携**: 閲覧中のページの情報を、外部のブックマークサービスやメモアプリに簡単に送信するボタンを追加する。\nつまり、「このサイトがこうだったらもっと便利なのに」という願いを、JavaScriptの力で実現するのがUserScriptの役割である。\n--\n# Violentmonkeyの主な特徴\n数あるUserScriptマネージャーの中でも、Violentmonkeyが持つ特徴は以下の通りである。\n**オープンソース**: ソースコードがすべて公開されており、透明性が高く、誰でも開発に参加できる。\n**高い互換性**: 最も有名なUserScriptマネージャーであるTampermonkeyやGreasemonkey向けに作られたスクリプトの多くが、そのまま動作する。\n**モダンなUI**: スクリプトの管理画面や設定メニューが直感的でわかりやすく、操作性に優れている。\n**便利なエディタ**: スクリプトを自作したり編集したりするための内蔵エディタは、シンタックスハイライトに対応している。\n# Tampermonkeyとの比較\nUserScriptマネージャーを選ぶ際、最も比較対象となるのが**Tampermonkey**である。両者の主な違いは以下の通りだ。\n| 特徴 | Violentmonkey | Tampermonkey |\n| :--- | :--- | :--- |\n| **ライセンス** | **オープンソース (MIT)** | クローズドソース |\n| **UI/UX** | モダンでシンプル | 伝統的で多機能 |\n| **同期機能** | 非常に豊富 | 主要クラウドに対応 |\n| **利用者数** | 多い | 非常に多い（事実上の標準） |\nどちらも非常に優れた拡張機能であるため、優劣をつけるのは難しい。**オープンソースであることの安心感や、モダンなUIを好むならViolentmonkey**が、**長年の実績と圧倒的な利用者数に裏打ちされた安定性を求めるならTampermonkey**が良い選択となるだろう。もちろん、両者のスクリプト互換性は高いため、移行も比較的容易である。\n# 導入方法\nViolentmonkeyの導入は非常に簡単だ。\n1.  **拡張機能のインストール**: ChromeウェブストアやFirefox ADD-ONSなど、利用中のブラウザの公式ストアで「Violentmonkey」を検索し、ブラウザに追加する。\n2.  **スクリプトを探す**: Greasy Fork などのUserScript配布サイトにアクセスし、目的のサイトで使えるスクリプトを探す。\n3.  **スクリプトのインストール**: 気に入ったスクリプトのページで「インストール」ボタンを押すとViolentmonkeyの確認画面が表示されるので、再度「インストール」をクリックすれば完了。\nこれだけで、すぐにWebページのカスタマイズが始まる。\n--\n# まとめ\n*Violentmonkey**は、Webブラウジングをより快適で効率的なものに変えるための、強力な「鍵」となる拡張機能である。\n面倒な作業の自動化から、UIの抜本的な改善まで、その可能性は無限大だ。オープンソースで開発が続けられている安心感もあり、初心者から上級者まで、すべてのユーザーにおすすめできる。\nぜひ一度試して、Webブラウジングを次のレベルへと引き上げてみてほしい。"
  },
  {
    "slug": "why-not-tree",
    "layout": "../../layouts/BaseMarkdownLayout.astro",
    "title": "ツリー構造の限界 ― なぜZettelkastenはリゾームを志向するのか",
    "date": "2025-07-15",
    "description": "静的なツリー構造では捉えきれない複雑な現実と、Obsidianで実践するリゾーム的思考の可能性について論じる。",
    "author": "AI Language Model (Gemini 2.5 Pro)",
    "tags": [
      "ツリー構造",
      "リゾーム",
      "Obsidian",
      "Zettelkasten"
    ],
    "content": "# はじめに：「ツリー」という便利な道具とその限界\n私たちは物事を考えるとき、無意識に「ツリー構造」というモデルを使っている。組織図やフォルダ階層のように、1つの根から枝分かれさせていく整理方法は、ごちゃごちゃした情報をスッキリさせるのにとても便利だ。Obsidianでノートを取り始めるときも、多くの人がまずこのツリー構造で整理しようとする。\nしかし、この方法は本当にベストなのだろうか。複雑な現実を理解し、新しいアイデアを生み出すには、ツリー構造だけでは不十分かもしれない。そこで登場するのが、哲学者ドゥルーズとガタリが提唱した「リゾーム」という考え方だ。\nこの記事では、なぜツリー構造に限界があるのか、そしてなぜZettelkasten、特にObsidianが「リゾーム」を目指すのかを、わかりやすく解説する。\n## 1. 現実にはたった1つの「根」はない\nツリー構造は、必ず「ルートフォルダ」のような、ただ1つの「根」を持つ。しかし、現実の世界の物事に、絶対的な根っこは存在しない。\n例えば、「現代社会の孤独」についてノートを作るとする。これを「経済」や「テクノロジー」といった1つのフォルダに入れるのは、あまり意味がない。なぜなら、孤独という問題は、経済、SNS、家族観など、無数の要素が原因になったり結果になったりしながら、複雑に絡み合っているからだ。1つの箱に押し込めた瞬間に、その複雑さは失われてしまう。\nリゾーム的なノートの取り方では、ノートを1つの場所に「分類」しない。代わりに、複数の文脈へと自由に「リンク」させる。そうすることで、現実世界の複雑な姿を、そのまま自分の知識ベースに映し取ろうとするのだ。\n## 2. 現実は上から下への「階層」ではない\nツリー構造は、親から子へ、上から下への一方通行の階層が基本だ。Obsidianの親子リンクもその一種と言える。しかし、現実の世界や知識のつながりは、決して一方通行ではない。\n例えば、会社組織では、組織図の上では経営陣がトップだ。しかし、現場の一社員の報告（子ノート）が、会社全体の理念（親ノート）をひっくり返すきっかけになることはよくある。これは、下から上への「ボトムアップ」の力だ。\nZettelkastenでも同じことが起きる。ふとしたメモ（子ノート）が、今まで常識だと思っていた大きな概念（親ノート）を覆し、知識全体をアップデートさせることがある。固定的な階層は、こうした創造的な「下剋上」の邪魔になる。現実は、あらゆる方向に線が伸びる、双方向のつながりに満ちている。\n## 3. 現実は「違うもの同士」がつながって生まれる\nツリー構造は、似たもの同士を同じ枝に集める。リンゴの木にブドウはならない。しかし、歴史的なイノベーションは、全く関係ないと思われていた「違うもの同士」が、偶然つながることで生まれてきた。これこそ、Obsidianの「友達リンク」が持つ大きな力だ。\nスマートフォンの誕生が良い例だ。あれは「電話」という木の新しい枝として生まれたのではない。「電話」「PC」「カメラ」「音楽プレイヤー」という、本来は別々の木だったものが、突如つながって生まれたリゾーム的な産物だ。\nこれは私たちの思考でも同じである。「生物学のノート」と「マーケティングのノート」が「共生」というキーワードでつながった時、新しいビジネスのアイデアが生まれるかもしれない。リゾーム的なネットワークを育てるということは、こうした「偶然の出会い」をただ待つのではなく、分野を横断するリンクを積極的に張ることで、偶然が起きやすい環境を自分で作ることなのだ。\n## 4. 現実は止まっておらず、常に変化する\nツリー構造は、一度作ると固定化されやすい。しかし、私たちの知識や考えは、常に変化し、成長し続ける「庭」のようなものだ。\n友人関係を「親友」「友人」と分類しても、その関係は明日には変わるかもしれない。ノートの関係性も同じで、新しい発見ひとつで、昨日までのつながりが全く違う意味を持つことがある。\nZettelkastenは、完成された「保管庫」ではない。ノートを追加し、リンクをつなぎ変えるたびに、ネットワーク全体が姿を変え、新しい思考を生み出していく、生きているシステムなのだ。ノートに「完成」はなく、常に書き換えられるのを待っている。\n## 結論：静的な「地図」から、思考が育つ「庭」へ\nつまり、ツリー構造とは「完成された静的な地図」のようなものだ。目的地を知るには便利だが、地図そのものは現実の土地ではない。\n私たちが向き合う現実、そして育てるべき知識とは、むしろ「常に変化し続ける、複雑な生態系（庭）」だ。そこでは、アイデアという獣が走り回り、リンクという菌類が地下にネットワークを広げ、予期せぬ洞察という植物が芽を出す。単純化された地図では、これを捉えることはできない。\nだから、ObsidianでZettelkastenを実践するときの問いは、「このノートをどこに分類すべきか？」ではなく、「このノートは何を思い出させ、何とつながるか？」に変わる。これは、世界を無理やり「整理」するのをやめ、その複雑さを複雑なまま受け入れるという、大きな態度の転換なのだ。\n--\n## 思考のコンパスでリゾームを育てる\nでは、具体的にどうすればリゾーム的なつながり、特に「友達リンク」を見つけられるのか。そのヒントとなるのが「思考のコンパス」だ。これは、論理的な思考（ツリー）と創造的な思考（リゾーム）を、意図的に引き出す仕組みである。\n縦の軸（北-南）：ツリーを育てる思考\n北（上流/起源）：ノートの「親」を探す行為だ。物事の前提や背景をたどり、階層をさかのぼる。\n南（下流/具体化）：ノートの「子」を生み出す行為だ。アイデアを具体例に落とし込み、階層をくだる。\nこの縦の軸は、知識を構造化し、深く掘り下げるためのツリー的な思考に対応する。\n横の軸（西-東）：リゾームを広げる思考\n西（強化/拡張）：これこそが「友達リンク」を見つけるための問いだ。「似た事例は？」「他の分野で応用できないか？」と考えることで、分野を横断し、予期せぬつながりを発見する。\n東（変革/発展）：「他との違いは？」「どう進化できるか？」と考えることで、既存の枠組みから抜け出す新しい道を探る。\nこの横の軸は、知識を水平に広げ、新しいアイデアを生み出すリゾーム的な思考に対応する。\n「友達リンクをどう結びつけるか？」という問いに悩んだとき、このコンパスの「西」と「東」へと思考を巡らせることが、具体的な道しるべとなる。"
  },
  {
    "slug": "x-bookmarks-exporter",
    "layout": "../../layouts/BaseMarkdownLayout.astro",
    "title": "X Bookmarks Exporter を公開しました。",
    "date": "2025-07-22",
    "description": "X Bookmarks Exporter",
    "author": "AI Language Model (Gemini 2.5 Pro)",
    "tags": [
      "UserScript",
      "X",
      "Violentmonkey"
    ],
    "content": "# 概要\nX Bookmarks Exporterは、X（旧Twitter）のブックマークをすべてCSVファイルとして書き出すためのUserScriptである。\nGitHub - Mekann2904/X-Bookmarks-Exporter\nこのスクリプトの最大の特徴は、自動スクロール機能にある。ページの読み込み範囲を少しずつ重ねながらスクロールすることで、動的に追加されるブックマークを収集する。\n--\n# 主な機能\n簡単操作: ブックマークページに表示されるボタン一つで、全自動でエクスポートを開始する。\n確実なデータ収集: 画面を少しずつスクロールし、読み込み範囲を重ねることで、ブックマークの取りこぼしを防ぐ。\n重複排除: 収集したデータはURLを元に管理され、重複したツイートは自動的に排除される。\nCSVエクスポート: 収集した全データを、Excelなどで扱いやすいUTF-8形式のCSVファイルとしてダウンロードする。\n--\n# 技術的な仕組み\n## 1. 操作ボタンの追加\nブックマークページを開くと、画面右上に「全ブックマークをエクスポート」ボタンが追加される。\nこれはで生成されたHTML要素で、クリックすると後述するメイン処理が実行される。処理中はボタンが「収集中...」といった表示に変わり、完了するまで無効化されるため、誤操作の心配はない。\n## 2. 自動スクロール\nこのスクリプトの心臓部であり、ブックマークの取りこぼしを防ぐための工夫が施されている。\nボタンをクリックすると、によって1.5秒ごとに画面の高さの90%ずつ自動でスクロールする処理が始まる。100%ではなく90%にすることで、スクロール範囲が重複（オーバーラップ）し、ツイートの読み込み漏れを防ぐ。\n各スクロール後には1秒間の待機時間を設け、Xサーバーからのデータ読み込みを待つ。ページの最後までスクロールし、コンテンツの高さに変化がなくなると、全件が読み込まれたと判断して処理を完了する。この仕組みにより、X特有の「無限スクロール」に賢く対応している。\n## 3. ツイート情報の抽出\n関数が、画面に表示されたツイートから必要な情報を抜き出す役割を担う。\n| 処理ステップ | 内容 |\n| :--- | :--- |\n| 要素の特定 | で、個々のツイート要素をすべて取得する。 |\n| データ抽出 | 各ツイート要素から、投稿者名、ユーザーID、ツイート本文、ツイートURLを抜き出す。 |\n| 重複排除 | 抽出したツイートのURLが既に収集済みでないかオブジェクトで確認し、新規データのみを格納する。 |\n## 4. CSVファイルのエクスポート\nすべてのブックマークを収集した後、関数がCSVファイルの生成とダウンロードを行う。\nCSVデータの作成: 収集したデータをCSV形式のテキストに変換する。この際、フィールドはダブルクォーテーションで囲み、特殊文字が正しく処理されるようにエスケープする。\n文字化け対策とダウンロード: CSVデータの先頭にBOM（Byte Order Mark）と呼ばれる特殊なデータを付与する。これにより、Microsoft Excelでファイルを開いた際の文字化けを防ぐ。その後、データをBlobオブジェクトに変換し、ダウンロード用のリンクを自動でクリックして処理を完了する。\n--\n# まとめ\nX Bookmarks Exporterは、Xの動的なページ構造に対応した「プログレッシブ＆オーバーラッピング・スクレイピング」という堅牢なアプローチを採用している。\nこれにより、ユーザーはボタンをクリックするだけで、手動では難しい大量のブックマーク情報を取得できる。"
  },
  {
    "slug": "youtube-embed",
    "layout": "../../layouts/BaseMarkdownLayout.astro",
    "title": "Astroで軽量YouTube埋め込み",
    "date": "2025-07-17",
    "description": "@astro-community/astro-embed-youtubeとgetImageによる最適化手法のまとめ",
    "author": "AI Language Model (Gemini 2.5 Pro)",
    "tags": [
      "Astro",
      "YouTube",
      "埋め込み"
    ],
    "content": "# 通常の使い方\nYouTube動画を軽量に埋め込むには、以下のようにします。\n にはYouTube動画のID（URLのv=以降）を指定します。\n はアクセシビリティ用（省略可）。\n# サムネイル画像をローカル最適化したい場合\nAstroのを使うことで、サムネイル画像をビルド時にダウンロードし、_astroディレクトリに配置できます。\n プロパティにローカル最適化した画像パスを渡せます。\n# 仕組み\n初期表示時はYouTube本体を読み込まず、サムネイル画像のみ表示\nユーザーが再生ボタンを押した時だけYouTubeのiframeをロード\nサムネイル画像はデフォルトでi.ytimg.comから取得\nを使えばサムネイルも自サーバーから配信可能\n--\n## まとめ\nで軽量YouTube埋め込み\nでサムネイルも最適化可能\n--\n## 参考リンク\n@astro-community/astro-embed-youtube (npm)\nAstro公式ドキュメント: 画像最適化 (astro:assets)\nAstro公式: Remote images（リモート画像の最適化）"
  }
]