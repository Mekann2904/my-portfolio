[
  {
    "slug": "astro-image-optimization",
    "layout": "../../layouts/BaseMarkdownLayout.astro",
    "title": "Astroの背景画像の最適化",
    "date": "2025-07-17",
    "description": "Astro v5での背景画像の最適化",
    "author": "AI Language Model (Gemini 2.5 Pro)",
    "tags": [
      "Astro",
      "画像最適化",
      "MDX",
      "Webパフォーマンス"
    ],
    "content": "\n子::[Astro + MDXで画像を最適化して埋め込む方法](../blog/image-embedding-guide)\n\n\n## 1. 背景画像のWebP最適化対応\n\nAstroで背景画像をWebP形式で最適化して使うには、`astro:assets`の`getImage`を利用する。`src/assets/output_gray.png`のようなローカル画像をimportし、frontmatterで以下のように記述する。\n\n```js\nimport { getImage } from 'astro:assets';\nimport outputGray from '../assets/output_gray.png';\nconst optimizedBg = await getImage({ src: outputGray, format: 'webp', quality: 80 });\n```\n\n`optimizedBg.src`には最適化されたWebP画像のURLが格納される。これを`<body>`のstyle属性でカスタムプロパティ`--faint-bg`にセットし、CSSで背景画像として利用する。\n\n## 2. CSSによる背景画像表示の仕組み\n\n`global.pcss`では`.bg-faint-image::before`で背景画像を表示する設計になっている。`background: var(--faint-bg)`でカスタムプロパティを参照し、`opacity: 0.2`で薄く表示する。bodyタグには`class=\"bg-faint-image\"`と`style=\"--faint-bg: url('/_astro/output_gray.XXXX.webp');\"`を指定する必要がある。\n\n```css\n.bg-faint-image::before {\n  content: \"\";\n  position: fixed;\n  inset: 0;\n  z-index: -1;\n  background: var(--faint-bg) no-repeat center center / cover;\n  opacity: 0.2;\n  pointer-events: none;\n}\n```\n\n## 3. 画像最適化のビルド・出力の流れ\n\nAstroの画像最適化は本番ビルド（`npm run build`）時のみ有効だ。開発サーバー（`npm run dev`）では最適化画像は生成されない。ビルド後、`dist/_astro/output_gray.XXXX.webp`のようなファイルが生成されていることを確認する。`npm run preview`で本番プレビューを行い、画像が正しく配信されているかをチェックする。\n\n## 4. 背景画像が表示されない場合のトラブルシュート\n\n- `global.pcss`の`.bg-faint-image`定義が本番ビルドにバンドルされているか確認する。\n- DevToolsで`<body>::before`が生成されているか、`background`スタイルが正しいか確認する。\n- 画像URLが有効か直接アクセスして確認する。\n- `opacity: 0.2`なので背景が非常に薄く見える。必要に応じて一時的に`opacity: 1`にして確認する。\n- 画像が表示されない場合、`sharp`がインストールされているか、Astroのバージョンが3以上か、キャッシュが残っていないかも疑う。\n\n## 5. その他の注意点\n\n- `sharp`パッケージがインストールされていないと画像最適化は動作しない。\n- Astroのバージョンが3以上であることを確認する。\n- 画像最適化やCSSのimport漏れ、キャッシュのクリアも重要なポイントだ。\n\n---\n\n## 参考リンク\n\n- [Astro公式: 画像最適化ガイド](https://docs.astro.build/ja/guides/assets/)\n"
  },
  {
    "slug": "command-palette-explanation",
    "layout": "../../layouts/BaseMarkdownLayout.astro",
    "title": "React Hooksを駆使した高機能コマンドパレットの実装",
    "date": "2025-07-17",
    "description": "React Hooksを活用し、キーワード・タグ・ユーザーによるAND検索やサジェスト機能を備えた高機能なコマンドパレットを実装する方法を解説する。",
    "author": "AI Language Model (Gemini 2.5 Pro)",
    "tags": [
      "React",
      "全文検索",
      "Hooks"
    ],
    "content": "\n### はじめに\n\nVS CodeやRaycast、Slackなどで見られる「コマンドパレット」は、現代的なアプリケーションに欠かせないUIとなりつつある。これはキーボードショートカット（多くは `Ctrl+K` や `Cmd+K`）で検索窓を呼び出し、さまざまな操作を高速に実行できる便利な機能だ。\n\n本記事では、ブログサイトに以下のような高機能なコマンドパレットを実装する方法を、React Hooksを活用して解説する。\n\n* キーボード主体の操作: ショートカット起動、ESCキーでのクローズ\n* 高度なAND検索: キーワード、タグ（`#tag`）、ユーザー（`>user`）の組み合わせ\n* 入力サジェスト: タグやユーザー名のインテリジェントな補完\n* ヘルプ機能: `?` 入力で使い方を表示\n\n---\n\n### アーキテクチャと設計思想\n\n効率的な実装のためには、まず全体の構造と設計のポイントを理解しておく必要がある。\n\n#### コンポーネントの全体像\n\n今回の実装は、役割の異なる2つのコンポーネントで構成されている。\n\n1.  **`BlogCommandPaletteWrapper.jsx`**\n    コマンドパレットの表示・非表示を管理し、起動トリガー（ボタンやショートカットキー）を提供するラッパー。\n\n2.  **`CommandPalette.jsx`**\n    検索ロジック、サジェスト、UIなど、コマンドパレット本体のすべての機能を担う中核コンポーネント。\n\n#### なぜ記事データをJSONで取得するのか？\n\nこの実装の核心は、クライアントサイドで全記事データを一括で取得し、検索処理を行う点にある。`CommandPalette.jsx` は、マウント時に `/blog-contents.json` というファイルを取得する。\n\n```javascript\n// CommandPalette.jsx\nuseEffect(() => {\n  fetch('/blog-contents.json')\n    .then(res => res.json())\n    .then(data => {\n      setPosts(data);\n      setLoading(false);\n    });\n}, []);\n```\n\nこの設計には、主に3つのメリットがある。\n\n* 高速な全文検索: サーバーとの通信なしに、手元にある全データに対して即座にフィルタリングを実行できる。これにより、入力のたびにリアルタイムで結果が更新される快適なUXが実現する。\n* 静的サイトとの親和性: AstroやNext.jsなどのフレームワークでは、ビルド時に全記事データをまとめて一つのJSONファイルとして出力することが容易。APIサーバーが不要で、CDNから高速に配信できる。\n* シンプルな実装: サーバーサイドの複雑な検索APIを実装する必要がなく、フロントエンドのロジックに集中できる。\n\n---\n\n### 実装の詳細\n\nここからは、具体的な実装をコンポーネントごとに解説する。\n\n#### ラッパーコンポーネント（`BlogCommandPaletteWrapper.jsx`）\n\nこのコンポーネントの責務はシンプルで、「表示状態の管理」と「起動インターフェースの提供」だ。\n\n```javascript\nimport React, { useState, useCallback, useEffect } from 'react';\nimport CommandPalette from './CommandPalette.jsx';\n\nexport default function BlogCommandPaletteWrapper({ posts }) {\n  const [showPalette, setShowPalette] = useState(false);\n  const openPalette = useCallback(() => setShowPalette(true), []);\n  const closePalette = useCallback(() => setShowPalette(false), []);\n\n  useEffect(() => {\n    const handler = (e) => {\n      if ((e.ctrlKey || e.metaKey) && e.key === 'k') {\n        e.preventDefault();\n        setShowPalette(true);\n      }\n    };\n    window.addEventListener('keydown', handler);\n    return () => window.removeEventListener('keydown', handler);\n  }, []);\n\n  return (\n    <>\n      <button /* ... */ onClick={openPalette}>\n        {/* ... SVG Icon ... */}\n      </button>\n      {showPalette && (\n        <CommandPalette posts={posts} onClose={closePalette} />\n      )}\n    </>\n  );\n}\n```\n\n* 状態管理: `useState` で表示状態（`showPalette`）を管理する。`useCallback` は、子コンポーネントに渡す関数の再生成を防ぐための最適化である。\n* ショートカット登録: `useEffect` で `keydown` イベントを監視し、`Ctrl/Cmd + K` が押されたらパレットを表示する。クリーンアップ関数でイベントリスナーを解除するのは、メモリリークを防ぐための重要な作法である。\n\n---\n\n#### コマンドパレット本体（`CommandPalette.jsx`）\n\nこのコンポーネントが機能の中核をなす。ロジックを「状態管理」「クエリ解析と検索」「サジェスト機能」の3ステップで解説する。\n\n##### 1. 状態管理とデータ取得\n\nまず、コンポーネントが必要とする全ての状態を定義し、前述の通り記事データを取得する。\n\n```javascript\nconst inputRef = useRef(null); // 入力欄へのフォーカス制御用\n```\n\n##### 2. クエリ解析と全文検索\n\n入力されたクエリを解析し、AND条件で記事をフィルタリングする検索機能の心臓部である。\n\n```javascript\nconst tagTokens = tokens.filter(t => t.startsWith('#')).map(t => t.slice(1).toLowerCase());\nconst userTokens = tokens.filter(t => t.startsWith('>')).map(t => t.slice(1).toLowerCase());\nconst keywordTokens = tokens.filter(t => !t.startsWith('#') && !t.startsWith('>')).map(t => t.toLowerCase());\n\n// AND検索ロジック (useMemoで最適化)\nconst filtered = useMemo(() => {\n  return posts.filter(post => {\n    // タグ条件\n    const postTags = (post.tags || []).map(t => t.toLowerCase());\n    if (!tagTokens.every(tag => postTags.includes(tag))) return false;\n    // ユーザー条件\n    const author = (post.author || '').toLowerCase();\n    if (!userTokens.every(user => author.includes(user))) return false;\n    // キーワード条件（全文検索）\n    const haystack = [post.title, post.description, post.content].join(' ').toLowerCase();\n    if (!keywordTokens.every(kw => haystack.includes(kw))) return false;\n    return true;\n  });\n}, [posts, tagTokens, userTokens, keywordTokens]);\n```\n\n* クエリ解析: 入力文字列を空白で分割し、`#` や `>` の接頭辞をもとに、タグ・ユーザー・キーワードの3種類に分類する。\n* 全文検索: キーワードは、記事の `title`, `description`, `content` を連結した一つの大きな文字列（`haystack`）に対して検索される。\n* AND検索: `Array.prototype.every()` を利用し、指定された全ての条件（タグ、ユーザー、キーワード）を満たす記事のみを抽出する。\n* 最適化: この重いフィルタリング処理は `useMemo` でメモ化し、依存する値が変更されたときのみ再計算されるようにしてパフォーマンスを確保している。\n\n##### 3. サジェストとキーボード操作\n\n入力中のトークンを検出し、候補を提示してキーボードで補完できるようにすることで、UXを大幅に向上させている。\n\n```javascript\n// サジェストロジック\nuseEffect(() => {\n  // 入力中の \"#\" or \">\" トークンを正規表現で検出\n  const match = query.match(/(?:^|\\s)([#>][^\\s]*)$/);\n  if (!match) { /* サジェストをクリア */ return; }\n  // ... マッチしたトークンに応じて候補を絞り込み、suggestionsステートを更新 ...\n}, [query, allTags, allUsers, tagTokens, userTokens]);\n\n// サジェストの選択と補完\nconst handleSuggestSelect = (item) => {\n  // ... 入力中のトークンを選択されたサジェストで置換 ...\n  setQuery(newQuery);\n  // ... サジェストをクリアし、入力欄にフォーカスを戻す ...\n};\n\n// キーボードイベントのハンドリング\nconst handleInputKeyDown = (e) => {\n  if (suggestions.length > 0) {\n    if (e.key === 'ArrowRight' || e.key === 'Tab' || e.key === 'Enter') {\n      e.preventDefault();\n      handleSuggestSelect(/* ...選択中のサジェスト... */);\n    }\n    // ... ArrowUp/Downでのサジェスト移動処理 ...\n  }\n};\n```\n\n* 候補検出: `useEffect` 内で、正規表現 `/(?:^|\\s)([#>][^\\s]*)$/` を使い、入力中の `#tag` や `>user` 形式のトークンを的確に捉える。\n* 候補提示: 全タグ・ユーザーリストから部分一致で候補を絞り込み、Stateを更新してUIに反映する。\n* キーボード操作: `Tab` や `Enter` キーでサジェストを確定し、クエリを補完する。`e.preventDefault()` でブラウザのデフォルト動作を抑制するのがポイントである。\n\n---\n\n### まとめと今後の展望\n\n本記事では、React Hooksを効果的に組み合わせることで、高機能かつパフォーマンスに優れたコマンドパレットを実装する方法を解説した。\n\n* `useState`/`useRef` で状態とDOM参照を管理\n* `useEffect` でデータ取得やイベントリスナなどの副作用を処理\n* `useMemo`/`useCallback` で重い処理や関数をメモ化し、パフォーマンスを最適化\n\nこれらの基本的なHooksを適切に使い分けることで、複雑なUIでも宣言的で見通しの良いコードを書くことができる。\n\nこの実装をベースとして、さらに以下のような拡張も考えられる。\n\n* ファジー検索: `Fuse.js` などのライブラリを導入し、より柔軟なあいまい検索に対応する。\n* 結果のキーボード操作: 矢印キーで検索結果自体を選択し、`Enter`でページ遷移できるようにする。\n* 検索対象の拡張: カテゴリやその他のメタデータも検索対象に加える。\n\nWebサイトに強力な検索機能と優れた操作性を提供したい場合、この実装は良い出発点となる。\n\n"
  },
  {
    "slug": "divergences",
    "layout": "../../layouts/BaseMarkdownLayout.astro",
    "title": "Obsidian 自作テーマ「Divergences」について",
    "date": "2025-07-17",
    "description": "Obsidian 自作テーマ「Divergences」の開発と導入手順について",
    "author": "AI Language Model (Gemini 2.5 Pro)",
    "tags": [
      "Obsidian",
      "自作テーマ",
      "CSS",
      "Divergences"
    ],
    "content": "import { Image } from 'astro:assets';\nimport divergencesImg from '../../assets/divergences.png';\n\n## 1. 緒言\n\n本レポートは、多機能ノートアプリ「Obsidian」において、ユーザー体験を向上させるためのインターフェースのパーソナライズ、具体的にはカスタムテーマ「Divergences」の開発から導入に至る全過程を記録し、その技術的詳細と知見を報告するものである。\n\nObsidianは高いカスタマイズ性を有するが、既存のテーマでは個々のユーザーが求める最適な作業環境を完全に満たすことが難しい場合がある。この課題認識が、本プロジェクトの出発点となった。本稿では、まず既存テーマのCSS（Cascading Style Sheets）改変の試みとその限界について述べ、次にゼロベースでの新規テーマ開発のプロセスと設計思想を詳述する。最終的に、完成したテーマ「Divergences」の具体的な導入手順と設定方法を網羅的に解説する。\n\n## 2. 既存テーマの改変と課題\n\n### 2.1. カスタマイズの動機と初期段階\n\n開発の初期段階では、既存のコミュニティ製テーマ「AnuPpuccin」（[https://github.com/AnubisNekhet/AnuPpuccin](https://github.com/AnubisNekhet/AnuPpuccin)) をベースとした。このテーマは優れたデザインであったが、長期間使用する中で「UIをさらに自身の作業に最適化したい」という要求が強まった。この要求が、カスタムCSSを用いた部分的な改変に着手する直接的な動機となった。\n\n当初の作業は、サイドバーの背景色やフォントの変更といった単純なものであった。しかし、Obsidianの内部構造は想定以上に複雑であり、各要素は詳細なクラスやセレクタによって制御されていた。\n\n### 2.2. 技術的課題\n\n改変作業において、いくつかの技術的課題が明らかになった。例えば、背景色一つを変更するにも、「プレビュー画面」「エディタ画面」「サイドバー」といった各要素に対応するセレクタを個別に特定する必要があった。単一の指定で一括変更が可能であるという初期の想定は誤りであり、開発者ツールを用いて要素を特定し、試行錯誤を繰り返す作業が求められた。\n\nさらに、ベーステーマのCSSは多層的に定義されており、レイアウト、配色、ホバーエフェクトなどが複雑に絡み合っていた。このため、一部の変更が予期せぬ別の要素に影響を及ぼすという事態が頻発した。リンクの色を変更した結果、背景色とのコントラストが不均衡になるなど、一つの修正が新たな修正箇所を生む「芋づる式」の作業が続いた。この過程はパズル的な面白さを持つ一方で、抜本的なデザイン変更の困難さを示唆していた。\n\n### 2.3. 自作テーマ開発への移行\n\n既存テーマの改変を続ける中で、以下のような具体的な改善要求が次々と生じた。\n\n>   * サイドバーのフォルダ間隔を詰め、情報の一覧性を向上させたい。\n>   * 見出しをより大きくし、視認性を高めたい。\n>   * リストの行間を広げ、可読性を改善したい。\n\nこれらの要求を満たすためには、既存のコードを追いかけるよりも、ゼロから自身の設計思想に基づいてテーマを構築する方が、効率的かつ自由度が高いと結論付けた。この結論が、次章で述べる新規テーマ「Divergences」の開発へと繋がった。\n\n## 3. 新規テーマ「Divergences」の開発\n\n### 3.1. 開発理念と目標\n\nテーマ「Divergences」の開発にあたり、最も重視した目標は「使っていて楽しい」という主観的な体験価値の創出である。これを実現するため、ダークブルーとパープルを基調とした幻想的な配色を採用した。背景を暗色系に統一し、ノードやリンクが紫や青系に発光するように見せることで、視認性と美的感覚を両立させる「発光エフェクト」のようなデザインを意識した。\n\n同時に、Obsidianが本来持つPKM（パーソナル・ナレッジ・マネジメント）ツールとしての実用性を損なわないよう、情報の整理しやすさとデザイン性のバランスを重視した。さらに、ユーザーが自身の好みに合わせて容易に調整できるよう、高いカスタマイズ性を持つ設計とした。\n\n<Image src={divergencesImg}  alt=\"Divergencesテーマのスクリーンショット\" />\n\n### 3.2. 開発手順\n\n開発は以下の4つの手順で進められた。\n\n1.  ベーススタイルの定義: テーマの全体的な雰囲気（落ち着いた色合いか、ポップな色味か）、背景色、フォントなどの基本方針を決定した。\n2.  ObsidianのCSS構造の理解: Obsidianのデフォルトスタイルを解析し、上書きすべき要素と方法を特定した。特にテーマの印象を大きく左右する透過度などの視覚効果については、調整すべき箇所を事前に洗い出した。\n3.  実装と調整: 実際にCSSコードを記述し、Obsidianの開発者ツール（Obsidian Developer Tools）を活用してリアルタイムでプレビューと微調整を繰り返した。要素の階層構造を調査しながら、段階的に理想形へと近づけた。\n4.  テーマの公開: 自身が「使いやすい」と判断できる水準に達した時点で、GitHubにリポジトリを作成してテーマを公開した。これにより、外部からのフィードバックを得る機会が生まれ、テーマの継続的な改善に繋がると考えた。\n\n## 4. 「Divergences」の導入手順\n\n本章では、開発したテーマ「Divergences」をユーザーが自身のObsidian環境に導入するための具体的な手順を詳述する。\n\n### 4.1. Step 1: テーマのインストール\n\n1.  テーマファイルの入手:\n    GitHubリポジトリ（[https://github.com/Mekann2904/obsidian-divergences-theme](https://github.com/Mekann2904/obsidian-divergences-theme)）にアクセスする。画面右側の「Releases」セクションから最新版の `Divergences.zip` をダウンロードする。\n2.  テーマフォルダへの配置:\n    Obsidianの「設定」→「外観」タブを開き、「テーマ」項目にあるフォルダアイコンをクリックしてテーマフォルダ（`.obsidian/themes`）にアクセスする。ダウンロードしたzipファイルを解凍し、中身のフォルダをこのthemesフォルダ内に配置する。\n3.  テーマの有効化:\n    Obsidianの「外観」設定に戻り、「テーマ」のドロップダウンメニューから「Divergences」を選択する。本テーマはダークモード専用設計であるため、同画面で「基本テーマ」を「ダーク」に設定し、「半透明ウィンドウを有効化」をオンにする必要がある。\n\n### 4.2. Step 2: 関連プラグインの導入\n\nテーマの全機能を利用するためには、以下のコミュニティプラグインの導入が必須または推奨される。\n\n  * obsidian-style-settings（必須）:\n    テーマの詳細なデザイン（配色、背景設定、エフェクト等）をGUIで調整するためのプラグイン。\n  * [obsidian-local-vault-server](https://github.com/Mekann2904/obsidian-local-vault-server-plugin.git)（推奨）:\n    ローカルPC上の画像を安全にObsidianの背景として利用するためのプラグイン。\n\n上記プラグインは、「設定」→「コミュニティプラグイン」から検索し、インストールと有効化を行う。\n\n### 4.3. Step 3: カスタム背景の設定\n\n1.  「設定」→「Style Settings」（プラグイン設定項目）を開き、「Divergences」のセクションを選択する。\n2.  「カスタム背景を有効化」をオンにする。\n3.  「画像のURLを設定」欄に、背景として使用したい画像のURL（例: `http://127.0.0.1:3000/image.jpg`）を入力する。\n4.  「フィルターの設定」項目で、背景の透明度やぼかし効果を任意の値に調整する。\n5.  背景が表示されない場合は、URLの正当性（ブラウザで直接開けるか）、フィルター設定、Obsidianの再起動などを確認する。\n\n## 5. 考察\n\n一連のテーマ開発を通じて得られた最大の収穫は、Obsidianの内部構造、特にDOM（Document Object Model）とCSSの関連性についての深い理解である。単に外観を変更するだけでなく、自身の作業スタイルに合わせてUIを最適化するプロセスは、ツールへの愛着を深め、生産性を向上させる上で極めて有効であった。\n\n既存テーマの改変から始めたことにより、CSSの継承や詳細度の概念を実践的に学ぶことができた。一方で、ゼロからの開発は、設計の自由度が高い反面、UIの全要素に対して一貫したデザイン思想を適用する必要があり、より包括的な設計能力が求められることを認識した。この経験は、今後のプラグイン開発やさらなるカスタマイズへの大きな足がかりとなるだろう。\n\n## 6. 結論\n\n本プロジェクトは、Obsidianの既存テーマに対する個人的な改善要求から始まり、最終的に完全オリジナルのカスタムテーマ「Divergences」を開発・公開し、その導入方法を確立するに至った。この一連の過程は、Obsidianを単なるノートアプリから、ユーザー個人のための最適化された創作空間へと変貌させることの価値を実証した。\n\n本レポートが、同様にObsidianのカスタマイズに挑戦しようとする他のユーザーにとって、一つの実践的な指針となることを期待する。\n\n-----\n\n補遺：フィードバックの要請\n本テーマに関する質問や改善提案、不具合報告は歓迎する。また、本テーマを使用した感想などを、X（旧Twitter）上でハッシュタグ `#Divergences` および `@Mekann2904` を付与して投稿いただければ、開発の励みとなる。"
  },
  {
    "slug": "download-box",
    "layout": "../../layouts/BaseMarkdownLayout.astro",
    "title": "ダウンロードボックスコンポーネントの使い方",
    "date": "2025-07-16T00:00:00.000Z",
    "description": "ダウンロードボックスコンポーネントの使い方",
    "author": "AI Language Model (Gemini 2.5 Pro)",
    "tags": [
      "components",
      "MDX",
      "Tailwind CSS"
    ],
    "content": "\nimport DownloadBox from '../../components/DownloadBox.jsx'\n\n## ダウンロードボックスコンポーネントの実装概要と使い方\n\n本稿では、Tailwind CSSを用いて作成した再利用可能なダウンロードUIコンポーネント（`DownloadBox.jsx`）の概要と、MDXでの使い方を解説する。\n\n    <DownloadBox\n      fileName=\"output_gray.png\"\n      fileUrl=\"/images/output_gray.png\"\n      client:load\n    />\n\n-----\n\n### 実装概要\n\n  - ファイル名（fileName）とファイルURL（fileUrl）をpropsとして受け取る。\n  - **ファイルサイズ**は自動で取得され、MB単位で表示される。\n  - **description**は任意で指定可能であり、省略した場合は表示されない。\n  - Tailwind CSSでデザインされており、どのMDXファイルでも容易に再利用が可能である。\n  - PDFや画像など、`public/`フォルダに配置した任意のファイルに対応する。\n\n\n-----\n\n### 使い方\n\n1.  **MDXファイルの先頭でインポートする**\n\n    ```mdx\n    import DownloadBox from '../../components/DownloadBox.jsx'\n    ```\n\n2.  **コンポーネントを呼び出す**\n\n    ##### 最小構成（ファイル名とURLのみ）\n\n    ```mdx\n    <DownloadBox\n      fileName=\"sample.pdf\"\n      fileUrl=\"/files/sample.pdf\"\n      client:load\n    />\n    ```\n\n    ##### 説明文を追加する場合\n\n    ```mdx\n    <DownloadBox\n      fileName=\"sample.pdf\"\n      fileUrl=\"/files/sample.pdf\"\n      description=\"サンプルファイルのダウンロード\"\n      client:load\n    />\n    ```\n\n-----\n\n### 注意点\n\n  - 対象ファイル（例: PDF）は`public/`フォルダに配置する必要がある。\n  - `fileUrl`には`/ファイル名`のようにルートパスで指定する。\n  - `description`は省略可能である。\n  - **MDXで使う場合は必ず`client:load`を付与する必要がある。**\n\n-----\n\n以上の手順により、どのMDX記事でも簡単にダウンロードボックスを表示できる。\n\n\n\n### 付録(コンポーネントのソースコード)\n\n\n```jsx\n\nimport { useEffect, useState } from 'react';\n\nfunction formatFileSize(size) {\n  if (!size) return '';\n  const num = Number(size);\n  const units = ['B', 'KB', 'MB', 'GB', 'TB'];\n  let idx = 0;\n  let value = num;\n  while (value >= 1024 && idx < units.length - 1) {\n    value = value / 1024;\n    idx++;\n  }\n  const display = value % 1 === 0 ? value.toString() : value.toFixed(2).replace(/\\.00$/, '').replace(/(\\.[1-9])0$/, '$1');\n  return `${display} ${units[idx]}`;\n}\n\nexport default function DownloadBox({ fileName, fileUrl, description = '' }) {\n  const [fileSize, setFileSize] = useState('');\n\n  useEffect(() => {\n    async function fetchFileSize() {\n      try {\n        const res = await fetch(fileUrl, { method: 'HEAD' });\n        const size = res.headers.get('content-length');\n        setFileSize(formatFileSize(size));\n      } catch (e) {\n        setFileSize('');\n      }\n    }\n    fetchFileSize();\n  }, [fileUrl]);\n\n  return (\n    <div className=\"border border-gray-800 rounded-md p-4 flex items-center gap-4 bg-gray-800 mb-4\">\n      <span className=\"text-2xl text-gray-400\">\n        {/* クリップアイコンSVG */}\n        <svg className=\"w-6 h-6\" fill=\"none\" stroke=\"currentColor\" strokeWidth=\"2\" viewBox=\"0 0 24 24\">\n          <path strokeLinecap=\"round\" strokeLinejoin=\"round\" d=\"M15.172 7l-6.586 6.586a2 2 0 102.828 2.828l7.07-7.07a4 4 0 00-5.657-5.657l-7.071 7.07a6 6 0 108.485 8.486l6.364-6.364\" />\n        </svg>\n      </span>\n      <div className=\"flex-1 min-w-0\">\n        <div className=\"font-semibold text-gray-200\">{fileName}</div>\n        {fileSize && <div className=\"text-xs text-gray-400\">{fileSize}</div>}\n        {description && <div className=\"text-xs text-gray-500\">{description}</div>}\n      </div>\n      <a\n        href={fileUrl}\n        download\n        className=\"inline-flex items-center px-4 py-2 bg-[#6366f1] text-white rounded hover:bg-[#4f46e5] hover:text-white transition\"\n      >\n        {/* ダウンロードアイコンSVG */}\n        <svg className=\"w-5 h-5 mr-2\" fill=\"none\" stroke=\"currentColor\" strokeWidth=\"2\" viewBox=\"0 0 24 24\">\n          <path strokeLinecap=\"round\" strokeLinejoin=\"round\" d=\"M4 16v2a2 2 0 002 2h12a2 2 0 002-2v-2M7 10l5 5m0 0l5-5m-5 5V4\" />\n        </svg>\n        ダウンロード\n      </a>\n    </div>\n  );\n} \n\n```"
  },
  {
    "slug": "image-embedding-guide",
    "layout": "../../layouts/BaseMarkdownLayout.astro",
    "title": "Astro + MDXで画像を最適化して埋め込む方法",
    "date": "2025-07-17",
    "author": "AI Language Model (Gemini 2.5 Pro)",
    "description": "AstroのMDX記事で画像を最適化しつつ埋め込むベストプラクティス",
    "tags": [
      "Astro",
      "画像最適化",
      "MDX",
      "Webパフォーマンス"
    ],
    "content": "import { Image } from 'astro:assets';\n\n子::[Astroブログ全体にプリフェッチを有効化する方法](../blog/prefetch-enabled)\n\nAstroのMDX記事で画像を最適化しつつ埋め込むには、以下の手順を踏む。\n\n## 1. frontmatterはYAMLのみ\n\nMDXファイルの先頭はYAML形式で記述し、importやJS式は書かない。\n\n```yaml\n---\nlayout: \"../../layouts/BaseMarkdownLayout.astro\"\ntitle: \"記事タイトル\"\ndate: \"2025-07-17\"\ntags: [\"タグ1\", \"タグ2\"]\n---\n```\n\n## 2. 画像のimport\n\nfrontmatterの直後で、astro:assetsのImageコンポーネントと画像ファイルをimportする。\n\n```js\nimport { Image } from 'astro:assets';\nimport sample1 from '../../assets/sample1.png';\nimport sample2 from '../../assets/sample2.jpg';\n```\n\n## 3. 画像の埋め込み\n\n本文中でimportした画像変数を`<Image />`のsrcに指定する。\n\n```mdx\n<Image src={sample1} alt=\"サンプル画像1\" />\n<Image src={sample2} alt=\"サンプル画像2\" />\n```\n\n## 4. 注意点\n\n- frontmatter内でimportやJS式は絶対に書かない（YAMLのみ）\n- 画像のimportはMDX本文の先頭で行う\n- `<img src={...} />`ではなく、必ず`<Image src={...} />`を使うことで最適化の恩恵を受ける\n- 画像は`src/assets/`配下に置く（`public/`配下は最適化されない）\n\n\n---\n\n## 参考\n\n- [Astro公式: 画像最適化ガイド](https://docs.astro.build/ja/guides/assets/)\n- [Astro公式: MDXガイド](https://docs.astro.build/ja/guides/integrations-guide/mdx/) "
  },
  {
    "slug": "mac-smartmontools",
    "layout": "../../layouts/BaseMarkdownLayout.astro",
    "title": "macOSでsmartmontoolsを使ってディスク情報を確認する",
    "date": "2025-07-15",
    "description": "macOSでsmartmontoolsを使ってディスク情報を確認する方法を解説する。",
    "author": "AI Language Model (Gemini 2.5 Pro)",
    "tags": [
      "macOS",
      "smartmontools",
      "ディスク情報",
      "温度情報"
    ],
    "content": "\n\nこの記事では、macOS環境で`smartmontools`というツールをHomebrewを使ってインストールし、接続されているディスクの情報を確認する手順を解説する。特に、外部ディスクの温度情報を取得する例を見ていく。\n\n\n### 1. smartmontoolsのインストール\n\n\n`smartmontools`は、S.M.A.R.T. (Self-Monitoring, Analysis and Reporting Technology) データを通じて、ハードディスクやSSDの健康状態を監視するためのユーティリティだ。macOSでは、Homebrewパッケージマネージャーを使って簡単にインストールできる。\n\n\nまず、以下のコマンドを実行して`smartmontools`をインストールする。\n\n```bash\nbrew install smartmontools\n```\n\n\n**実行結果の解説:**\n\n```\n==> Auto-updating Homebrew...\n...\n==> Auto-updated Homebrew!\nUpdated 2 taps (homebrew/core and homebrew/cask).\n...\n==> Downloading https://ghcr.io/v2/homebrew/core/smartmontools/manifests/7.5\n...\n==> Pouring smartmontools--7.5.arm64_sequoia.bottle.tar.gz\n🍺  /opt/homebrew/Cellar/smartmontools/7.5: 37 files, 2.3MB\n==> Running `brew cleanup smartmontools`...\n```\n\n\n上記の出力から、Homebrewが自動更新された後、`smartmontools`のバージョン7.5が正常にインストールされたことがわかる。インストールされたファイルは`/opt/homebrew/Cellar/smartmontools/7.5`に配置され、インストール後に自動的にクリーンアップが実行されている。\n\n\n### 2. 接続されているディスクの識別\n\n\n`smartmontools`を使ってディスク情報を取得する前に、どのディスクを対象にするか識別しなければならない。`diskutil list`コマンドを使うと、システムに接続されているすべてのディスクとそのパーティション情報を一覧表示できる。\n\n```bash\ndiskutil list\n```\n\n\n**実行結果の解説:**\n\n```\n/dev/disk0 (internal, physical):\n   #:                       TYPE NAME                    SIZE       IDENTIFIER\n   0:      GUID_partition_scheme                        *251.0 GB   disk0\n   1:             Apple_APFS_ISC Container disk1         524.3 MB   disk0s1\n   2:                 Apple_APFS Container disk3         245.1 GB   disk0s2\n   3:        Apple_APFS_Recovery Container disk2         5.4 GB     disk0s3\n\n/dev/disk3 (synthesized):\n   #:                       TYPE NAME                    SIZE       IDENTIFIER\n   ...\n\n/dev/disk4 (external, physical):\n   #:                       TYPE NAME                    SIZE       IDENTIFIER\n   0:      GUID_partition_scheme                        *2.0 TB     disk4\n   1:                        EFI NO NAME                 209.7 MB   disk4s1\n   2:                 Apple_APFS Container disk5         2.0 TB     disk4s2\n\n/dev/disk5 (synthesized):\n   #:                       TYPE NAME                    SIZE       IDENTIFIER\n   0:      APFS Container Scheme -                      +2.0 TB     disk5\n                                 Physical Store disk4s2\n   1:                APFS Volume MSI M482 - Data         37.7 GB    disk5s1\n   2:                APFS Volume MSI M482                10.7 GB    disk5s2\n   ...\n```\n\n\nこの出力から、以下のディスクが確認できる。\n\n*   `/dev/disk0`: 251.0 GBの内部物理ディスク。macOSのシステムがインストールされている。\n*   `/dev/disk4`: 2.0 TBの外部物理ディスク。このディスクはAPFSコンテナ`disk5`を含んでいる。\n*   `/dev/disk5`: `/dev/disk4s2`から合成されたAPFSコンテナで、「MSI M482 - Data」や「MSI M482」といったボリュームが含まれている。\n\n今回は、この外部ディスク`/dev/disk5`の情報を取得することにする。\n\n\n### 3. smartctlで温度情報を取得\n\n\n`smartmontools`に含まれる`smartctl`コマンドを使って、特定のディスクのS.M.A.R.T.情報を取得できる。ディスクの温度情報を確認するには、`-a`オプションで全てのS.M.A.R.T.情報を表示し、`grep -i temperature`で温度に関する行をフィルタリングするのが便利だ。\n\n`smartctl`はディスクに直接アクセスするため、`sudo`コマンドで管理者権限が必要になる。\n\n```bash\nsudo smartctl -a /dev/disk5 | grep -i temperature\n```\n\n\n**実行結果の解説:**\n\n```\nPassword:\nTemperature:                        37 Celsius\nWarning  Comp. Temperature Time:    0\nCritical Comp. Temperature Time:    0\nTemperature Sensor 1:               37 Celsius\n```\n\n\n上記の出力から、外部ディスク`/dev/disk5`の現在の温度は**37℃**であることがわかる。また、温度センサー1の値も同じく37℃を示している。\n\n\n### まとめ\n\n\nこの手順により、Homebrewを使って`smartmontools`をmacOSにインストールし、`diskutil list`でディスクを識別した後、`smartctl`コマンドで外部ディスクの温度情報を正常に取得できた。\n\n\n\n"
  },
  {
    "slug": "obsidian-textlint",
    "layout": "../../layouts/BaseMarkdownLayout.astro",
    "title": "高度な日本語校正をObsidianで実現する \n「Textlint Highlighter Plugin」をリリースしました",
    "date": "2025-07-09",
    "description": "Obsidianで動作するtextlintプラグインです。リアルタイムで文章を校正し、問題箇所をエディタ上でハイライト表示します。",
    "author": "AI Language Model (Gemini 2.5 Pro)",
    "tags": [
      "Obsidian",
      "textlint",
      "プラグイン",
      "日本語校正"
    ],
    "content": "\n\nこの記事はAIによって自動生成されました。\n\n## はじめに\n\nObsidianで日本語の文章を書くすべてのユーザーへ。  \n「表記ゆれをなくしたい」「技術記事の品質を上げたい」  \n「チームのドキュメントルールを統一したい」  \nそんな悩みを解決するプラグインが **Obsidian Textlint Highlighter Plugin** です。\n\nこのプラグインは、Node.js製の強力なテキスト校正ツール \\`textlint\\` をObsidianに統合します。これにより、あなたの文章作成は次のレベルへと引き上げられます。本記事では、その強力な機能と具体的な使い方を解説します。\n\n  \n\n  \n\n---\n\n## 1\\. Textlint Highlighter Pluginとは\n\nこのプラグインは、入力された日本語のテキストを \\`textlint\\` を使ってリアルタイムに解析し、問題点をエディタ上にハイライト表示するものです。これにより、文章の推敲にかかる時間を削減し、より執筆に集中できる環境を構築します。\n\n### textlintとは\n\n[textlint](https://textlint.github.io/) は、プラグイン形式で校正ルールを追加できる、非常に柔軟で強力なテキスト校正エンジンです。例えば、以下のようなチェックを自動化できます。\n\n- **技術文書向けの表記統一** (例: \\`textlint-rule-preset-ja-technical-writing\\`)\n- **敬体（ですます調）と常体（である調）の混在チェック** (例: \\`textlint-rule-no-mix-dearu-desumasu\\`)\n- **表記ゆれのチェック** (例: \\`textlint-rule-prh\\` を利用し、\\`サーバー\\` / \\`サーバ\\` などを統一)\n- **漢字の閉じ開き** (例: \\`textlint-rule-ja-no-mixed-period\\`)\n\nこれらのルールを組み合わせることで、自分だけ、あるいはチームだけの文章執筆規約を構築できます。\n\n---\n\n## 2\\. 主な機能詳解\n\n### 2.1. リアルタイム・ハイライト機能\n\nこのプラグインを有効にすると、エディタ上で文章を記述するそばから自動で校正が実行されます。\\`textlint\\` が検出した問題点は即座にハイライトされ、マウスカーソルを合わせると「なぜこれが問題なのか」という理由が表示されます。\n\nこれにより、修正すべき箇所とその理由が一目瞭然となり、文章を書きながらスムーズに推敲作業を進めることができます。\n\n### 2.2. 柔軟なルールカスタマイズ\n\n本プラグインの真価は、その圧倒的なカスタマイズ性にあります。\n\n### prh.ymlによる表記ゆれチェック\n\n\\`prh.yml\\` というYAMLファイルを使うことで、独自の表記ゆれ辞書を簡単に作成できます。\n\n例: \\`prh.yml\\`\n\n```python\nrules:\n  - expected: \"サーバー\"\n    pattern: \"サーバ\"\n  - expected: \"Web\"\n    pattern: \"/web/i\" # 正規表現も利用可能\n```\n\nこのファイルをプラグイン設定で読み込ませるだけで、「サーバ」と書かれた箇所を自動で検出し、「サーバー」への修正を促してくれます。\n\n### Textlintルールの導入\n\nnpmで配布されている豊富なtextlintルールを導入できます。ただし、別途Node.js環境が必要になる場合があります。  \n例えば、\\`textlint-rule-preset-ja-technical-writing\\` のようなプリセットを導入すれば、技術文書執筆における一般的な規約をまとめて適用できます。\n\n### 2.3. ルール・プリセット管理画面\n\n「たくさんのルールを導入したのはいいけど、今どれが有効になっているか分からない…」  \nそんな悩みを解決するのが、設定画面にある **ルール・プリセット一覧表示機能** です。\n\nプラグイン設定画面を開くと、現在読み込まれている全てのルールが一覧で表示されます。\n\n- ルールのON/OFF: 各ルールの横にあるチェックボックスを切り替えるだけで、一時的にルールを無効化できます。\n- 設定の確認: どのルールファイルから読み込まれているかが明記されており、管理が容易です。\n\nこれにより、プロジェクトや文書の種類に応じて、適用するルールセットを柔軟に切り替えるといった高度な使い方が可能になります。\n\n### 2.4. パフォーマンスへの配慮\n\nリアルタイムで校正処理が走ると、特に長文のファイルではパフォーマンスが心配になります。  \nこのプラグインは、その点も考慮して設計されています。\n\n- キャッシュ機構: 一度校正した結果をキャッシュし、変更があった部分だけを再計算することで、エディタの応答性を損なわないように工夫されています。\n\nこれにより、数万文字を超えるような長大なドキュメントでも、ストレスなく執筆を続けることができます。\n\n> obsidian-textlint-highlighter-plugin  \n> かなりサクサクで、30万字のメモでも動作を確認。 [pic.twitter.com/qlr8s5kJzU](https://t.co/qlr8s5kJzU)\n> \n> — Mekann (@Mekann2904) [July 8, 2025](https://twitter.com/Mekann2904/status/1942542541712416909?ref_src=twsrc%5Etfw)\n\n  \n\n---\n\n## 3\\. インストールと設定\n\n### インストール\n\n1. **\\[推奨\\] BRATを利用する方法**\n\t1. コミュニティプラグイン \\`Obsidian42 - BRAT\\` をインストールします。\n\t2. BRATの設定で \\`Add Beta plugin\\` を選択します。本プラグインのGitHubリポジトリURL (\\` [https://github.com/Mekann2904/obsidian-textlint-highlighter-plugin](https://github.com/Mekann2904/obsidian-textlint-highlighter-plugin/releases)) を入力します。\n\t3. プラグインが自動でインストールされたら、コミュニティプラグイン設定で有効化します。\n2. **手動でインストールする方法**\n\t1. プラグインの [リリースページ](https://github.com/Mekann2904/obsidian-textlint-highlighter-plugin/releases) から最新の \\`obsidian-textlint-highlighter-plugin.zip\\`をダウンロードします。\n\t2. ダウンロードしたファイルをプラグインフォルダ内に配置します。\n\t3. Obsidianを再起動（またはリロード）し、コミュニティプラグイン設定で有効化します。\n\n### 初期設定\n\n1. プラグインを有効化したら、設定画面を開きます。\n2. \\`prh.yml\\` を利用する場合は、ファイルの場所を \\`prh.yml file path\\` に設定します。Obsidian Vault内のパスを指定できます。\n\n---\n\n## 4\\. まとめ\n\n**Obsidian Textlint Highlighter Plugin** は、単なる誤字脱字チェッカーではありません。\\`textlint\\` の強力なエコシステムと連携し、Obsidianをプロフェッショナルな日本語の執筆環境へと変貌させる可能性を秘めたツールです。\n\n- **リアルタイムでの高速なフィードバック**\n- **\\`prh.yml\\` や textlintルールによる無限のカスタマイズ性**\n- **分かりやすいルール管理UI**\n- **長文でも安心のパフォーマンス**\n\nこれらの特徴により、ブロガー、技術者、編集者、学生など、質の高い日本語文章を求めるすべての人にとって、不可欠なプラグインとなるでしょう。\n\nぜひこのプラグインを導入して、より快適で創造的な執筆活動をお楽しみください。\n\n---\n\n## ライセンス\n\nMIT License\n\n  \n\n高度な日本語校正をObsidianで実現する「Textlint Highlighter Plugin」をリリースしました｜Mekann"
  },
  {
    "slug": "prefetch-enabled",
    "layout": "../../layouts/BaseMarkdownLayout.astro",
    "title": "Astroブログ全体にプリフェッチを有効化する方法",
    "date": "2025-07-17",
    "author": "AI Language Model (Gemini 2.5 Pro)",
    "tags": [
      "Astro",
      "プリフェッチ",
      "Webパフォーマンス"
    ],
    "description": "Astro v5以降では、サイト全体のリンクに対してプリフェッチ（事前読み込み）を簡単に有効化できます。この記事では、実際にブログ全体でプリフェッチを有効化した手順と、その効果・注意点についてまとめます。",
    "content": "\n\nAstro v4.5から導入され、v5でさらに強化されたクライアントサイドのルーティングとプリフェッチ機能は、Webサイトのパフォーマンスを劇的に向上させる。この記事では、Astroのプリフェッチ機能の仕組みから、サイト全体で有効化する具体的な設定方法、詳細なオプション、そして注意点までを深く掘り下げて解説する。\n\n-----\n\n### プリフェッチとは？\n\nプリフェッチ（Prefetching）とは、ユーザーが次に行うであろうナビゲーションを予測し、遷移先のページリソースを事前に読み込んでおく技術である。これにより、ユーザーがリンクをクリックした際には、すでにデータがブラウザにキャッシュされているため、ネットワークの待ち時間なしに瞬時にページを表示できる。\n\nAstroのプリフェッチは、単にHTMLを読み込むだけではない。遷移先のページのHTMLと、そのページのレンダリングに必要なCSSやJavaScriptモジュールも同時に取得するため、非常に高速なページ遷移が実現する。この機能はAstroのView Transitionsと連携することで、滑らかなアニメーションを伴うシームレスなユーザー体験を提供する。\n\n-----\n\n### プリフェッチの設定方法 \n\nプリフェッチの挙動は、`astro.config.mjs` ファイルと、個別の `<a>` タグに付与する `data-astro-prefetch` 属性で細かく制御できる。\n\n#### サイト全体での設定\n\n`astro.config.mjs` に `prefetch` オブジェクトを追加することで、サイト全体のデフォルトの挙動を定義できる。\n\n```js\n// astro.config.mjs\nimport { defineConfig } from 'astro/config';\n\nexport default defineConfig({\n  // ...他の設定...\n  prefetch: {\n    // trueにすると、ビューポート内の全リンクをプリフェッチ対象にする\n    prefetchAll: true,\n    // data-astro-prefetch属性がないリンクのデフォルト戦略を指定\n    // 'tap', 'hover', 'viewport', 'load' から選択可能\n    defaultStrategy: 'viewport',\n    // プリフェッチ要求間の最小クールダウン時間（ミリ秒）\n    cooldown: 50, \n  },\n  // ...他の設定...\n});\n```\n\n`prefetchAll: true` は、ビューポート（画面表示領域）に入った全てのリンクを自動的にプリフェッチの対象にするための強力なオプションだ。ブログやドキュメントサイトのように、ページ間の回遊性が高いサイトに最適である。\n\n`defaultStrategy` は、`prefetchAll` が `true` の場合や、`data-astro-prefetch=\"true\"` が指定されたリンクが、どのタイミングでプリフェッチされるかを決定する。\n\n#### プリフェッチ戦略（Prefetch Strategies）\n\nAstroでは、プリフェッチを実行するタイミングを4つの戦略から選択できる。\n\n  * `hover` (デフォルト): リンクにマウスカーソルが乗った時、またはフォーカスが当たった時にプリフェッチする。最も一般的な戦略。\n  * `tap`: ユーザーがリンクをタップまたはクリックする直前にプリフェッチする。モバイルデバイスでの応答性を高めるのに有効。\n  * `viewport`: リンクがビューポートに入った瞬間にプリフェッチする。ユーザーが目にする可能性が高いリンクを積極的に読み込む。\n  * `load`: ページの初期読み込みが完了した直後に、ページ上の全ての対象リンクをプリフェッチする。最も重要なリンク（CTAボタンなど）に使うと効果的。\n\n#### 個別リンクでの設定\n\nサイト全体の設定を上書きしたい場合や、特定のリンクだけ挙動を変えたい場合は、`<a>` タグに `data-astro-prefetch` 属性を直接記述する。\n\n```html\n<a href=\"/large-file.zip\" data-astro-prefetch=\"false\">Download Zip</a>\n\n<a href=\"/next-article\" data-astro-prefetch=\"viewport\">次の記事へ</a>\n\n<a href=\"/signup\" data-astro-prefetch=\"load\">今すぐ登録</a>\n\n<a href=\"/about\" data-astro-prefetch=\"true\">About</a>\n```\n\n`data-astro-prefetch=\"false\"` を指定すれば、そのリンクはプリフェッチの対象外となる。これは、外部リンクやサイズの大きいファイルへのリンクに設定すると良いだろう。\n\n-----\n\n### 期待できる効果 \n\n  * 圧倒的なページ遷移速度: ユーザーがリンクをクリックした時点でリソースがキャッシュされているため、体感速度が劇的に向上する。特にブログ記事間の移動などが極めてスムーズになる。\n  * ユーザー体験（UX）の向上: 待ち時間のない軽快な操作感は、ユーザー満足度を直接的に高める。\n  * コアウェブバイタルの改善: ページ遷移の応答性が向上するため、特に `Interaction to Next Paint (INP)` のスコア改善に寄与する可能性がある。\n\nプリフェッチの動作は、ブラウザの開発者ツールの「ネットワーク」タブを開き、リンクにホバーしたりスクロールしたりすることで、実際のリクエストが発生していることを確認できる。\n\n-----\n\n### 注意点とベストプラクティス \n\nプリフェッチは強力な機能だが、無計画な導入は逆効果になる可能性もある。\n\n  * データ通信量の増加: 全てのリンクを無差別にプリフェッチすると、ユーザーが実際には訪問しないページのデータまでダウンロードしてしまい、特にモバイル環境ではデータ通信量を無駄に消費させてしまう。`prefetchAll: true` を使う際は、サイトの特性をよく考慮する必要がある。\n  * サーバー負荷: 静的生成されたサイト（SSG）では大きな問題になりにくいが、サーバーサイドレンダリング（SSR）で動的なリクエストが多いサイトの場合、プリフェッチによるリクエスト増加がサーバー負荷を高める可能性がある。\n  * 戦略的な使い分け:\n      * ブログ記事一覧: ユーザーが次に読みそうな記事リンクには `data-astro-prefetch=\"viewport\"` が効果的だ。\n      * グローバルナビゲーション: 常に表示されているヘッダーやフッターのリンクには `hover` や `tap` が適している。\n      * 重要なCTA: 「購入」や「登録」など、ユーザーに必ず踏んでほしいリンクには `load` を使い、最速で表示できるように準備しておくのが良いだろう。\n      * 外部リンク・ファイル: プリフェッチが不要なリンクには、必ず `data-astro-prefetch=\"false\"` を設定する。\n\n### 参考リンク\n\n  * [Astro公式プリフェッチガイド（日本語）](https://docs.astro.build/ja/guides/prefetch/)\n\n-----\n\nAstroのプリフェッチ機能は、設定が非常に簡単でありながら、Webサイトのパフォーマンスとユーザー体験を飛躍的に向上させるポテンシャルを秘めている。サイトのコンテンツやユーザーの行動を考慮し、最適な戦略を選択することが、その効果を最大限に引き出す鍵となるだろう。"
  },
  {
    "slug": "vault-organizer",
    "layout": "../../layouts/BaseMarkdownLayout.astro",
    "title": "Obsidianプラグイン「vault-organizer」リリースしました",
    "date": "2025-02-23",
    "description": "Obsidianプラグイン「vault-organizer」のリリースについて",
    "author": "AI Language Model (Gemini 2.5 Pro)",
    "tags": [
      "Obsidian",
      "プラグイン",
      "vault-organizer"
    ],
    "content": "\n\n## Obsidianプラグイン「vault-organizer」リリースしました\n\n\n日々のノート管理や情報整理をさらに効率化するために、新たなプラグイン「vault-organizer」をリリースしました。今回のリリースでは、 Obsidian Vaultのルートファイル を自動的に整理し、作業環境のクリーンアップと効率アップを実現することを目指しています。\n\n  \n\n---\n\n## はじめに\n\nObsidianは柔軟性とカスタマイズ性の高さが魅力ですが、 Vaultのルート に大量のファイルが散在すると、情報の検索や管理が煩雑になることもあります。そこで、今回リリースした「vault-organizer」は、ファイルの種類やルールに基づいて自動で整理・移動を行うことで、ユーザーの作業効率を向上させるプラグインです。\n\n[https://github.com/Mekann2904/obsidian-vault-organizer-plugin](https://github.com/Mekann2904/obsidian-vault-organizer-plugin)\n\n---\n\n## 「vault-organizer」の概要\n\n「vault-organizer」は、以下のような特徴を持っています。\n\n- 自動分類機能  \n\tファイル拡張子や設定したルールに応じて、 Vaultルートのファイル を指定のフォルダへ自動移動。例えば、Markdownファイルは特定のディレクトリに、画像ファイルは画像用のフォルダに振り分けることが可能です。\n- Undo（元に戻す）機能  \n\t誤ってファイルが移動された場合でも、 移動前の状態に戻す Undo機能を搭載。安全に整理作業を実行できます。\n- 直感的な設定画面  \n\tプラグイン専用の設定タブから、各ファイルタイプに対する移動先フォルダの設定が簡単に行えます。フォルダ選択のための サジェスト機能 も用意されており、手軽に設定が可能です。\n\n実行はリボンまたはコマンドパレットから行えます。  \n\n\n\n---\n\n## 主な機能\n\n### 手動によるファイル移動\n\n- 対象ファイルのスキャン  \n\tVaultのルートフォルダにあるファイルを自動的に検出し、拡張子に応じた移動先へ分類します。\n- 安全なリネーム  \n\t同名ファイルが存在する場合でも、連番を付与することで名前の衝突を防ぎ、確実に移動を実行します。\n\n### Undo機能\n\n- 移動履歴の保持  \n\t実行したファイル移動の履歴を保存し、必要に応じて一括で元に戻すことができます。\n\n---\n\n## インストール方法\n\n1. プラグインのダウンロード  \n\tGitHubなどで公開している「vault-organizer」のコードを入手し、Obsidianのプラグインフォルダに配置してください。\n2. サードパーティプラグインの有効化  \n\tObsidianの設定画面から「Community Plugins」を選択し、サードパーティ製プラグインの利用を有効にしてください。\n3. プラグインの起動  \n\tプラグイン一覧から「vault-organizer」を探し、\\[Enable\\]ボタンをクリックして有効化してください。\n\n---\n\n## 使用例\n\n例えば、以下のようなシナリオで活用できます。\n\n- ノート整理  \n\tVaultのルートに散らばるMarkdownファイルを、指定した「Notes」フォルダに自動で整理。\n- 画像管理  \n\t画像ファイル（.png,.jpegなど）を、事前に設定した「Images」フォルダへ一括移動。\n- ファイル整理の失敗も安心  \n\t誤って移動してしまった場合でも、Undo機能で一括復元が可能なため、安心して操作できます。\n\n---\n\n## 今後の展望\n\n今回のリリースは第一弾として、基本的なファイル整理機能を中心に実装しました。今後は、ユーザーからのフィードバックがあれば、さらに高度な分類ルールの追加や、カスタムスクリプトとの連携機能など、機能拡張を予定しています。Obsidianユーザーの皆様の作業環境が、よりスマートに、そして快適になることを目指して開発を進めてまいります。\n\n---\n\n## まとめ\n\n「vault-organizer」は、Obsidianを日常的に利用されている方々にとって、Vault内のファイル整理を大幅に効率化する新たなツールです。自動分類、Undo機能、直感的な設定画面など、多くの機能を備えている本プラグインをぜひお試しください。皆様からのフィードバックもお待ちしております！\n\n今後とも、より良いプラグインの提供に努めてまいりますので、どうぞご期待ください。\n\n---\n\n以上、Obsidianプラグイン「vault-organizer」リリースのお知らせでした。  \n皆様の快適なノートライフをサポートできることを心より願っています。\n\n  \n"
  },
  {
    "slug": "why-not-tree",
    "layout": "../../layouts/BaseMarkdownLayout.astro",
    "title": "ツリー構造の限界 ― なぜZettelkastenはリゾームを志向するのか",
    "date": "2025-07-15",
    "description": "静的なツリー構造では捉えきれない複雑な現実と、Obsidianで実践するリゾーム的思考の可能性について論じる。",
    "author": "AI Language Model (Gemini 2.5 Pro)",
    "tags": [
      "ツリー構造",
      "リゾーム",
      "Obsidian",
      "Zettelkasten"
    ],
    "content": "\n## はじめに：「ツリー」という便利な道具とその限界\n\n私たちは物事を考えるとき、無意識に「ツリー構造」というモデルを使っている。組織図やフォルダ階層のように、1つの根から枝分かれさせていく整理方法は、ごちゃごちゃした情報をスッキリさせるのにとても便利だ。Obsidianでノートを取り始めるときも、多くの人がまずこのツリー構造で整理しようとする。\n\nしかし、この方法は本当にベストなのだろうか。複雑な現実を理解し、新しいアイデアを生み出すには、ツリー構造だけでは不十分かもしれない。そこで登場するのが、哲学者ドゥルーズとガタリが提唱した「リゾーム」という考え方だ。\n\nこの記事では、なぜツリー構造に限界があるのか、そしてなぜZettelkasten、特にObsidianが「リゾーム」を目指すのかを、わかりやすく解説する。\n\n### 1. 現実にはたった1つの「根」はない\n\nツリー構造は、必ず「ルートフォルダ」のような、ただ1つの「根」を持つ。しかし、現実の世界の物事に、絶対的な根っこは存在しない。\n\n例えば、「現代社会の孤独」についてノートを作るとする。これを「経済」や「テクノロジー」といった1つのフォルダに入れるのは、あまり意味がない。なぜなら、孤独という問題は、経済、SNS、家族観など、無数の要素が原因になったり結果になったりしながら、複雑に絡み合っているからだ。1つの箱に押し込めた瞬間に、その複雑さは失われてしまう。\n\nリゾーム的なノートの取り方では、ノートを1つの場所に「分類」しない。代わりに、複数の文脈へと自由に「リンク」させる。そうすることで、現実世界の複雑な姿を、そのまま自分の知識ベースに映し取ろうとするのだ。\n\n### 2. 現実は上から下への「階層」ではない\n\nツリー構造は、親から子へ、上から下への一方通行の階層が基本だ。Obsidianの親子リンクもその一種と言える。しかし、現実の世界や知識のつながりは、決して一方通行ではない。\n\n例えば、会社組織では、組織図の上では経営陣がトップだ。しかし、現場の一社員の報告（子ノート）が、会社全体の理念（親ノート）をひっくり返すきっかけになることはよくある。これは、下から上への「ボトムアップ」の力だ。\n\nZettelkastenでも同じことが起きる。ふとしたメモ（子ノート）が、今まで常識だと思っていた大きな概念（親ノート）を覆し、知識全体をアップデートさせることがある。固定的な階層は、こうした創造的な「下剋上」の邪魔になる。現実は、あらゆる方向に線が伸びる、双方向のつながりに満ちている。\n\n### 3. 現実は「違うもの同士」がつながって生まれる\n\nツリー構造は、似たもの同士を同じ枝に集める。リンゴの木にブドウはならない。しかし、歴史的なイノベーションは、全く関係ないと思われていた「違うもの同士」が、偶然つながることで生まれてきた。これこそ、Obsidianの「友達リンク」が持つ大きな力だ。\n\nスマートフォンの誕生が良い例だ。あれは「電話」という木の新しい枝として生まれたのではない。「電話」「PC」「カメラ」「音楽プレイヤー」という、本来は別々の木だったものが、突如つながって生まれたリゾーム的な産物だ。\n\nこれは私たちの思考でも同じである。「生物学のノート」と「マーケティングのノート」が「共生」というキーワードでつながった時、新しいビジネスのアイデアが生まれるかもしれない。リゾーム的なネットワークを育てるということは、こうした「偶然の出会い」をただ待つのではなく、分野を横断するリンクを積極的に張ることで、偶然が起きやすい環境を自分で作ることなのだ。\n\n### 4. 現実は止まっておらず、常に変化する\n\nツリー構造は、一度作ると固定化されやすい。しかし、私たちの知識や考えは、常に変化し、成長し続ける「庭」のようなものだ。\n\n友人関係を「親友」「友人」と分類しても、その関係は明日には変わるかもしれない。ノートの関係性も同じで、新しい発見ひとつで、昨日までのつながりが全く違う意味を持つことがある。\n\nZettelkastenは、完成された「保管庫」ではない。ノートを追加し、リンクをつなぎ変えるたびに、ネットワーク全体が姿を変え、新しい思考を生み出していく、生きているシステムなのだ。ノートに「完成」はなく、常に書き換えられるのを待っている。\n\n### 結論：静的な「地図」から、思考が育つ「庭」へ\n\nつまり、ツリー構造とは「完成された静的な地図」のようなものだ。目的地を知るには便利だが、地図そのものは現実の土地ではない。\n\n私たちが向き合う現実、そして育てるべき知識とは、むしろ「常に変化し続ける、複雑な生態系（庭）」だ。そこでは、アイデアという獣が走り回り、リンクという菌類が地下にネットワークを広げ、予期せぬ洞察という植物が芽を出す。単純化された地図では、これを捉えることはできない。\n\nだから、ObsidianでZettelkastenを実践するときの問いは、「このノートをどこに分類すべきか？」ではなく、「このノートは何を思い出させ、何とつながるか？」に変わる。これは、世界を無理やり「整理」するのをやめ、その複雑さを複雑なまま受け入れるという、大きな態度の転換なのだ。\n\n---\n\n### 思考のコンパスでリゾームを育てる\n\nでは、具体的にどうすればリゾーム的なつながり、特に「友達リンク」を見つけられるのか。そのヒントとなるのが「思考のコンパス」だ。これは、論理的な思考（ツリー）と創造的な思考（リゾーム）を、意図的に引き出す仕組みである。\n\n縦の軸（北-南）：ツリーを育てる思考\n\n* 北（上流/起源）：ノートの「親」を探す行為だ。物事の前提や背景をたどり、階層をさかのぼる。\n* 南（下流/具体化）：ノートの「子」を生み出す行為だ。アイデアを具体例に落とし込み、階層をくだる。\n\nこの縦の軸は、知識を構造化し、深く掘り下げるためのツリー的な思考に対応する。\n\n横の軸（西-東）：リゾームを広げる思考\n\n* 西（強化/拡張）：これこそが「友達リンク」を見つけるための問いだ。「似た事例は？」「他の分野で応用できないか？」と考えることで、分野を横断し、予期せぬつながりを発見する。\n* 東（変革/発展）：「他との違いは？」「どう進化できるか？」と考えることで、既存の枠組みから抜け出す新しい道を探る。\n\nこの横の軸は、知識を水平に広げ、新しいアイデアを生み出すリゾーム的な思考に対応する。\n\n「友達リンクをどう結びつけるか？」という問いに悩んだとき、このコンパスの「西」と「東」へと思考を巡らせることが、具体的な道しるべとなる。"
  },
  {
    "slug": "youtube-embed",
    "layout": "../../layouts/BaseMarkdownLayout.astro",
    "title": "Astroで軽量YouTube埋め込み",
    "date": "2025-07-17",
    "description": "@astro-community/astro-embed-youtubeとgetImageによる最適化手法のまとめ",
    "author": "AI Language Model (Gemini 2.5 Pro)",
    "tags": [
      "Astro",
      "YouTube",
      "埋め込み"
    ],
    "content": "\nimport { YouTube } from '@astro-community/astro-embed-youtube';\n\n## 通常の使い方\n\nYouTube動画を軽量に埋め込むには、以下のようにします。\n\n```mdx\nimport { YouTube } from '@astro-community/astro-embed-youtube';\n\n<YouTube id=\"AAAAAAA\" title=\"動画タイトル\" />\n```\n\n- `id` にはYouTube動画のID（URLのv=以降）を指定します。\n- `title` はアクセシビリティ用（省略可）。\n\n<YouTube id=\"jNQXAC9IVRw\" title=\"Me at the zoo\" />\n\n## サムネイル画像をローカル最適化したい場合\n\nAstroの`getImage`を使うことで、サムネイル画像をビルド時にダウンロードし、_astroディレクトリに配置できます。\n\n```js\nimport { getImage } from \"astro:assets\";\nconst posterURL = \"https://i.ytimg.com/vi/AAAAAAA/hqdefault.jpg\";\nconst posterImage = await getImage({ src: posterURL, inferSize: true });\n\n<YouTube id=\"AAAAAAA\" title=\"動画タイトル\" poster={posterImage.src} />\n```\n\n- `poster` プロパティにローカル最適化した画像パスを渡せます。\n\n## 仕組み\n\n- 初期表示時はYouTube本体を読み込まず、サムネイル画像のみ表示\n- ユーザーが再生ボタンを押した時だけYouTubeのiframeをロード\n- サムネイル画像はデフォルトでi.ytimg.comから取得\n- `getImage`を使えばサムネイルも自サーバーから配信可能\n\n---\n\n### まとめ\n\n- `@astro-community/astro-embed-youtube`で軽量YouTube埋め込み\n- `getImage`でサムネイルも最適化可能\n\n---\n\n### 参考リンク\n\n- [@astro-community/astro-embed-youtube (npm)](https://www.npmjs.com/package/@astro-community/astro-embed-youtube)\n- [Astro公式ドキュメント: 画像最適化 (astro:assets)](https://docs.astro.build/ja/guides/assets/)\n- [Astro公式: Remote images（リモート画像の最適化）](https://docs.astro.build/en/guides/images/#remote-images)\n\n"
  }
]